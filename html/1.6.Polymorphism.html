<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Polymorphism</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="current numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-getting-to-know" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-getting-to-know" checked="checked"></label><span class="number">1.</span> <span class=""><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></span></div>
              <table><tr class="numbered"><td class="num">1.1.</td><td><a href="Getting-to-Know-Lean/Evaluating-Expressions/#evaluating">Evaluating Expressions</a></td></tr><tr class="numbered"><td class="num">1.2.</td><td><a href="Getting-to-Know-Lean/Types/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Types">Types</a></td></tr><tr class="numbered"><td class="num">1.3.</td><td><a href="Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions">Functions and Definitions</a></td></tr><tr class="numbered"><td class="num">1.4.</td><td><a href="Getting-to-Know-Lean/Structures/#structures">Structures</a></td></tr><tr class="numbered"><td class="num">1.5.</td><td><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns">Datatypes and Patterns</a></td></tr><tr class="current numbered"><td class="num">1.6.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">Polymorphism</a></td></tr><tr class="numbered"><td class="num">1.7.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences">Additional Conveniences</a></td></tr><tr class="numbered"><td class="num">1.8.</td><td><a href="Getting-to-Know-Lean/Summary/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-polymorphism" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-polymorphism" checked="checked"></label><span class="number">1.6.</span> <span class="current"><a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">Polymorphism</a></span></div>
              <table><tr class="numbered"><td class="num">1.6.1.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Linked-Lists">Linked Lists</a></td></tr><tr class="numbered"><td class="num">1.6.2.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Implicit-Arguments">Implicit Arguments</a></td></tr><tr class="numbered"><td class="num">1.6.3.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes">More Built-In Datatypes</a></td></tr><tr class="numbered"><td class="num">1.6.4.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Messages-You-May-Meet">Messages You May Meet</a></td></tr><tr class="numbered"><td class="num">1.6.5.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Exercises">Exercises</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns" rel="prev" title="1.5. Datatypes and Patterns"><span class="arrow">←</span><span class="where">1.5. Datatypes and Patterns</span></a><a class="local-button active" href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences" rel="next" title="1.7. Additional Conveniences"><span class="where">1.7. Additional Conveniences</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              1.6. Polymorphism<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=polymorphism" title="Permalink">🔗</a></span></h1>
            <p>
              Just as in most languages, types in Lean can take arguments.
For instance, the type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> describes lists of natural numbers, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code> describes lists of strings, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span></code> describes lists of lists of points.
This is very similar to <code>List&lt;Nat&gt;</code>, <code>List&lt;String&gt;</code>, or <code>List&lt;List&lt;Point&gt;&gt;</code> in a language like C# or Java.
Just as Lean uses a space to pass an argument to a function, it uses a space to pass an argument to a type.</p>
            <p>
              In functional programming, the term <em>polymorphism</em> typically refers to datatypes and definitions that take types as arguments.
This is different from the object-oriented programming community, where the term typically refers to subclasses that may override some behavior of their superclass.
In this book, “polymorphism” always refers to the first sense of the word.
These type arguments can be used in the datatype or definition, which allows the same datatype or definition to be used with any type that results from replacing the arguments' names with some other types.</p>
            <div class="paragraph">
              <p>
                The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code> structure requires that both the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code> fields are <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code>s.
There is, however, nothing about points that require a specific representation for each coordinate.
A polymorphic version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>, called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span></code>, can take a type as an argument, and then use that type for both fields:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-18354">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.24946" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-18383">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-PPoint.x" data-verso-hover="114">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24946" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-PPoint.y" data-verso-hover="115">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.24946" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-18407">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="64">Repr</span></code></div>
            <p>
              Just as a function definition's arguments are written immediately after the name being defined, a structure's arguments are written immediately after the structure's name.
It is customary to use Greek letters to name type arguments in Lean when no more specific name suggests itself.
<code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="50">Type</span></code> is a type that describes other types, so <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code> all have type <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="50">Type</span></code>.</p>
            <div class="paragraph">
              <p>
                Just like <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span></code> can be used by providing a specific type as its argument:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18597">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-natOrigin" data-verso-hover="116">natOrigin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint.x" data-verso-hover="117">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint.y" data-verso-hover="117">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                In this example, both fields are expected to be <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>s.
Just as a function is called by replacing its argument variables with its argument values, providing <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span></code> with the type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> as an argument yields a structure in which the fields <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint.x" data-verso-hover="114">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint.y" data-verso-hover="115">y</span></code> have the type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, because the argument name <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.24946" data-verso-hover="113">α</span></code> has been replaced by the argument type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.
Types are ordinary expressions in Lean, so passing arguments to polymorphic types (like <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span></code>) doesn't require any special syntax.</p>
              </div>
            <div class="paragraph">
              <p>
                Definitions may also take types as arguments, which makes them polymorphic.
The function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span></code> replaces the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint.x" data-verso-hover="119">x</span></code> field of a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span></code> with a new value.
In order to allow <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span></code> to work with <em>any</em> polymorphic point, it must be polymorphic itself.
This is achieved by having its first argument be the type of the point's fields, with later arguments referring back to the first argument's name.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18929">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26325" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26327" data-verso-hover="120">point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26325" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.26329" data-verso-hover="121">newX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26325" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26325" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26327" data-verso-hover="120">point</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-19005">with</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint.x" data-verso-hover="119">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.26329" data-verso-hover="121">newX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                In other words, when the types of the arguments <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.26327" data-verso-hover="120">point</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.26329" data-verso-hover="121">newX</span></code> mention <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.26325" data-verso-hover="113">α</span></code>, they are referring to <em>whichever type was provided as the first argument</em>.
This is similar to the way that function argument names refer to the values that were provided when they occur in the function's body.</p>
              </div>
            <div class="paragraph">
              <p>
                This can be seen by asking Lean to check the type of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span></code>, and then asking it to check the type of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-19160">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                <pre>replaceX : (α : Type) → PPoint α → α → PPoint α</pre></div>
              <p>
                This function type includes the <em>name</em> of the first argument, and later arguments in the type refer back to this name.
Just as the value of a function application is found by replacing the argument name with the provided argument value in the function's body, the type of a function application is found by replacing the argument's name with the provided value in the function's return type.
Providing the first argument, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, causes all occurrences of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.26325" data-verso-hover="113">α</span></code> in the remainder of the type to be replaced with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-19331">#check</span><span class="inter-text"> </span><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code><div class="information">
                <pre>replaceX Nat : PPoint Nat → Nat → PPoint Nat</pre></div>
              <p>
                Because the remaining arguments are not explicitly named, no further substitution occurs as more arguments are provided:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-19482">#check</span><span class="inter-text"> </span><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="const token" data-binding="const-natOrigin" data-verso-hover="116">natOrigin</span></code><div class="information">
                <pre>replaceX Nat natOrigin : Nat → PPoint Nat</pre></div>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-19647">#check</span><span class="inter-text"> </span><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="const token" data-binding="const-natOrigin" data-verso-hover="116">natOrigin</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code><div class="information">
                <pre>replaceX Nat natOrigin 5 : PPoint Nat</pre></div>
              </div>
            <div class="paragraph">
              <p>
                The fact that the type of the whole function application expression was determined by passing a type as an argument has no bearing on the ability to evaluate it.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-19799" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="const token" data-binding="const-natOrigin" data-verso-hover="116">natOrigin</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code><div class="information">
                <pre>{ x := 5, y := 0 }</pre></div>
              </div>
            <div class="paragraph">
              <p>
                Polymorphic functions work by taking a named type argument and having later types refer to the argument's name.
However, there's nothing special about type arguments that allows them to be named.
Given a datatype that represents positive or negative signs:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-29785" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign" data-verso-hover="122">Sign</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-29800">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">pos</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">neg</span></code></div>
            <div class="paragraph">
              <p>
                it is possible to write a function whose argument is a sign.
If the argument is positive, the function returns a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, while if it's negative, it returns an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-29894">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-posOrNegThree" data-verso-hover="125">posOrNegThree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.48675" data-verso-hover="126">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign" data-verso-hover="122">Sign</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-29929" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48675" data-verso-hover="126">s</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-29929" data-verso-hover="100">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">Sign.neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-29983" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.48675" data-verso-hover="126">s</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-29983" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">Sign.neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="27">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code><p>
                Because types are first class and can be computed using the ordinary rules of the Lean language, they can be computed by pattern-matching against a datatype.
When Lean is checking this function, it uses the fact that the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code>-expression in the function's body corresponds to the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code>-expression in the type to make <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> be the expected type for the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">pos</span></code> case and to make <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code> be the expected type for the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">neg</span></code> case.</p>
              </div>
            <div class="paragraph">
              <p>
                Applying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-posOrNegThree" data-verso-hover="125">posOrNegThree</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">pos</span></code> results in the argument name <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.48675" data-verso-hover="126">s</span></code> in both the body of the function and its return type being replaced by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">pos</span></code>.
Evaluation can occur both in the expression and its type:</p>
              <div class="eval-steps">
                <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-posOrNegThree" data-verso-hover="125">posOrNegThree</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-30399" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-30399" data-verso-hover="100">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">Sign.neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-30463" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-30463" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">Sign.neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="27">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-30540" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-30540" data-verso-hover="100">with</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.pos" data-verso-hover="123">Sign.pos</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sign.neg" data-verso-hover="124">Sign.neg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">3</span></code></div>
              </div>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Linked-Lists">
                1.6.1. Linked Lists</h2>
              <div class="paragraph">
                <p>
                  Lean's standard library includes a canonical linked list datatype, called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span></code>, and special syntax that makes it more convenient to use.
Lists are written in square brackets.
For instance, a list that contains the prime numbers less than 10 can be written:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19894">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">7</span><span class="unknown token" data-binding="">]</span></code></div>
              <div class="paragraph">
                <p>
                  Behind the scenes, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span></code> is an inductive datatype, defined like this:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-20098" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.28840" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-20125">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List.nil" data-verso-hover="129">nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28840" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28840" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28840" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28840" data-verso-hover="113">α</span></code><p>
                  The actual definition in the standard library is slightly different, because it uses features that have not yet been presented, but it is substantially similar.
This definition says that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span></code> takes a single type as its argument, just as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span></code> did.
This type is the type of the entries stored in the list.
According to the constructors, a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.28840" data-verso-hover="113">α</span></code> can be built with either <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.nil" data-verso-hover="129">nil</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span></code>.
The constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.nil" data-verso-hover="129">nil</span></code> represents empty lists and the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span></code> is used for non-empty lists.
The first argument to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span></code> is the head of the list, and the second argument is its tail.
A list that contains <code class="math inline">n</code> entries contains <code class="math inline">n</code> <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span></code> constructors, the last of which has <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.nil" data-verso-hover="129">nil</span></code> as its tail.</p>
                </div>
              <div class="paragraph">
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span></code> example can be written more explicitly by using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span></code>'s constructors directly:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20482">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-explicitPrimesUnder10" data-verso-hover="131">explicitPrimesUnder10</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">7</span><span class="inter-text"> </span><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><p>
                  These two definitions are completely equivalent, but <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span></code> is much easier to read than <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-explicitPrimesUnder10" data-verso-hover="131">explicitPrimesUnder10</span></code>.</p>
                </div>
              <div class="paragraph">
                <p>
                  Functions that consume <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span></code>s can be defined in much the same way as functions that consume <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code>s.
Indeed, one way to think of a linked list is as a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> that has an extra data field dangling off each <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> constructor.
From this point of view, computing the length of a list is the process of replacing each <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span></code> with a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> and the final <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.nil" data-verso-hover="129">nil</span></code> with a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">zero</span></code>.
Just as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span></code> took the type of the fields of the point as an argument, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span></code> takes the type of the list's entries.
For example, if the list contains strings, then the first argument is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code>: <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="135">"Sourdough"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="136">"bread"</span><span class="unknown token" data-binding="">]</span></code>.
It should compute like this:</p>
                <div class="eval-steps">
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="135">"Sourdough"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="136">"bread"</span><span class="unknown token" data-binding="">]</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="135">"Sourdough"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="136">"bread"</span><span class="inter-text"> </span><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="136">"bread"</span><span class="inter-text"> </span><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">2</span></code></div>
                </div>
              <div class="paragraph">
                <p>
                  The definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span></code> is both polymorphic (because it takes the list entry type as an argument) and recursive (because it refers to itself).
Generally, functions follow the shape of the data: recursive datatypes lead to recursive functions, and polymorphic datatypes lead to polymorphic functions.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-20774">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29378" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.29381" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29378" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-20823" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29381" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-20823" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29414" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29415" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29378" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.29415" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">)</span></code></div>
              <p>
                Names such as <code>xs</code> and <code>ys</code> are conventionally used to stand for lists of unknown values.
The <code>s</code> in the name indicates that they are plural, so they are pronounced “exes” and “whys” rather than “x s” and “y s”.</p>
              <div class="paragraph">
                <p>
                  To make it easier to read functions on lists, the bracket notation <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span></code> can be used to pattern-match against <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.nil" data-verso-hover="129">nil</span></code>, and an infix <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">::</span></code> can be used in place of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.List.cons" data-verso-hover="130">cons</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22121">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30726" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30729" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30726" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-22170" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30729" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-22170" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30772" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30773" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Oooops.length" data-verso-hover="134">length</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30726" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30773" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">)</span></code></div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Implicit-Arguments">
                1.6.2. Implicit Arguments</h2>
              <div class="paragraph">
                <p>
                  Both <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-replaceX" data-verso-hover="118">replaceX</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ooops.length" data-verso-hover="134">length</span></code> are somewhat bureaucratic to use, because the type argument is typically uniquely determined by the later values.
Indeed, in most languages, the compiler is perfectly capable of determining type arguments on its own, and only occasionally needs help from users.
This is also the case in Lean.
Arguments can be declared <em>implicit</em> by wrapping them in curly braces instead of parentheses when defining a function.
For example, a version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BetterPlicity.replaceX" data-verso-hover="138">replaceX</span></code> with an implicit type argument looks like this:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22341">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BetterPlicity.replaceX" data-verso-hover="138">replaceX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.30917" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30919" data-verso-hover="120">point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30917" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.30921" data-verso-hover="121">newX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30917" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30917" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30919" data-verso-hover="120">point</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-22417">with</span><span class="inter-text"> </span><span class="const token" data-binding="const-PPoint.x" data-verso-hover="119">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.30921" data-verso-hover="121">newX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                  It can be used with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-natOrigin" data-verso-hover="116">natOrigin</span></code> without providing <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> explicitly, because Lean can <em>infer</em> the value of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.30917" data-verso-hover="113">α</span></code> from the later arguments:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">{ x := 5, y := 0 }</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-22541" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-BetterPlicity.replaceX" data-verso-hover="138">replaceX</span><span class="inter-text"> </span><span class="const token" data-binding="const-natOrigin" data-verso-hover="116">natOrigin</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code><div class="information">
                  <pre>{ x := 5, y := 0 }</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Similarly, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span></code> can be redefined to take the entry type implicitly:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22621">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.33376" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33379" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33376" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-22670" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33379" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-22670" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33422" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33423" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33423" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                  This <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span></code> function can be applied directly to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">4</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-22815" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span></code><div class="information">
                  <pre>4</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  In the standard library, Lean calls this function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.length" data-verso-hover="140">List.length</span></code>, which means that the dot syntax that is used for structure field access can also be used to find the length of a list:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">4</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-22949" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.length" data-verso-hover="140">length</span></code><div class="information">
                  <pre>4</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Just as C# and Java require type arguments to be provided explicitly from time to time, Lean is not always capable of finding implicit arguments.
In these cases, they can be provided using their names.
For example, a version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.length" data-verso-hover="140">List.length</span></code> that only works for lists of integers can be specified by setting <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">α</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">List.length : List Int → Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-23091">#check</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-List.length" data-verso-hover="140">List.length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                  <pre>List.length : List Int → Nat</pre></div>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes">
                1.6.3. More Built-In Datatypes</h2>
              <p>
                In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts.</p>
              <section>
                <h3 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes--Option">
                  1.6.3.1. <code>Option</code></h3>
                <p>
                  Not every list has a first entry—some lists are empty.
Many operations on collections may fail to find what they are looking for.
For instance, a function that finds the first entry in a list may not find any such entry.
It must therefore have a way to signal that there was no first entry.</p>
                <p>
                  Many languages have a <code>null</code> value that represents the absence of a value.
Instead of equipping existing types with a special <code>null</code> value, Lean provides a datatype called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span></code> that equips some other type with an indicator for missing values.
For instance, a nullable <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code> is represented by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code>, and a nullable list of strings is represented by the type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="unknown token" data-binding="">)</span></code>.
Introducing a new type to represent nullability means that the type system ensures that checks for <code>null</code> cannot be forgotten, because an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code> can't be used in a context where an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code> is expected.</p>
                <div class="paragraph">
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span></code> has two constructors, called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option.some" data-verso-hover="143">some</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option.none" data-verso-hover="144">none</span></code>, that respectively represent the non-null and null versions of the underlying type.
The non-null constructor, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option.some" data-verso-hover="143">some</span></code>, contains the underlying value, while <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option.none" data-verso-hover="144">none</span></code> takes no arguments:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-23443" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34753" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-23479">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Option.none" data-verso-hover="144">none</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34753" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Option.some" data-verso-hover="143">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.34759" data-verso-hover="121">val</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34753" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.34753" data-verso-hover="113">α</span></code></div>
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span></code> type is very similar to nullable types in languages like C# and Kotlin, but it is not identical.
In these languages, if a type (say, <code>Boolean</code>) always refers to actual values of the type (<code>true</code> and <code>false</code>), the type <code>Boolean?</code> or <code>Nullable&lt;Boolean&gt;</code> additionally admits the <code>null</code> value.
Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for <code>null</code>, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't.
However, these nullable types differ from Lean's <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span></code> in one very important way, which is that they don't allow multiple layers of optionality.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code> can be constructed with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span></code>, or <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="27">360</span><span class="unknown token" data-binding="">)</span></code>.
Kotlin, on the other hand, treats <code>T??</code> as being equivalent to <code>T?</code>.
This subtle difference is rarely relevant in practice, but it can matter from time to time.</p>
                <div class="paragraph">
                  <p>
                    To find the first entry in a list, if it exists, use <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Floop.List.head?" data-verso-hover="147">List.head?</span></code>.
The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin.
In the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Floop.List.head?" data-verso-hover="147">List.head?</span></code>, an underscore is used to represent the tail of the list.
In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data.
Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored.</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-27157">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Floop.List.head?" data-verso-hover="147">List.head?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.39233" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.39236" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39233" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39233" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-27216" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39236" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-27216" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39275" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.39275" data-verso-hover="121">y</span></code></div>
                <p>
                  A Lean naming convention is to define operations that might fail in groups using the suffixes <code>?</code> for a version that returns an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span></code>, <code>!</code> for a version that crashes when provided with invalid input, and <code>D</code> for a version that returns a default value when the operation would otherwise fail.
Following this pattern, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.head" data-verso-hover="148">List.head</span></code> requires the caller to provide mathematical evidence that the list is not empty, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.head?" data-verso-hover="149">List.head?</span></code> returns an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Option" data-verso-hover="141">Option</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.head!" data-verso-hover="150">List.head!</span></code> crashes the program when passed an empty list, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.headD" data-verso-hover="151">List.headD</span></code> takes a default value to return in case the list is empty.
The question mark and exclamation mark are part of the name, not special syntax, as Lean's naming rules are more liberal than many languages.</p>
                <div class="paragraph">
                  <p>
                    Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.head?" data-verso-hover="149">head?</span></code> is defined in the <code>List</code> namespace, it can be used with accessor notation:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">some 2</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-27381" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-primesUnder10" data-verso-hover="127">primesUnder10</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.head?" data-verso-hover="152">head?</span></code><div class="information">
                    <pre>some 2</pre></div>
                  <p>
                    However, attempting to test it on the empty list leads to two errors:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-27707" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize implicit argument 'α'
  @_root_.List.head? ?m.41793 []
context:
⊢ Type ?u.41790</code></span></span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize implicit argument 'α'
  @List.nil ?m.41793
context:
⊢ Type ?u.41790</code></span></span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.head?" data-verso-hover="152">head?</span></span></code><div class="error">
                    <pre>don't know how to synthesize implicit argument 'α'
  @List.nil ?m.41793
context:
⊢ Type ?u.41790</pre></div>
                  <div class="error">
                    <pre>don't know how to synthesize implicit argument 'α'
  @_root_.List.head? ?m.41793 []
context:
⊢ Type ?u.41790</pre></div>
                  </div>
                <div class="paragraph">
                  <p>
                    This is because Lean was unable to fully determine the expression's type.
In particular, it could neither find the implicit type argument to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.head?" data-verso-hover="149">List.head?</span></code>, nor the implicit type argument to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span></code>.
In Lean's output, <code>?m.XYZ</code> represents a part of a program that could not be inferred.
These unknown parts are called <em>metavariables</em>, and they occur in some error messages.
In order to evaluate an expression, Lean needs to be able to find its type, and the type was unavailable because the empty list does not have any entries from which the type can be found.
Explicitly providing a type allows Lean to proceed:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">none</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-28124" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.head?" data-verso-hover="152">head?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                    <pre>none</pre></div>
                  <p>
                    The type can also be provided with a type annotation:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">none</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-28232" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.head?" data-verso-hover="152">head?</span></code><div class="information">
                    <pre>none</pre></div>
                  <p>
                    The error messages provide a useful clue.
Both messages use the <em>same</em> metavariable to describe the missing implicit argument, which means that Lean has determined that the two missing pieces will share a solution, even though it was unable to determine the actual value of the solution.</p>
                  </div>
                </section>
              <section>
                <h3 id="prod">
                  1.6.3.2. <code>Prod</code><span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=prod" title="Permalink">🔗</a></span></h3>
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Prod" data-verso-hover="153">Prod</span></code> structure, short for “Product”, is a generic way of joining two values together.
For instance, a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod" data-verso-hover="154">Prod</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code> contains a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> and a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code>.
In other words, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PPoint" data-verso-hover="112">PPoint</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> could be replaced by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod" data-verso-hover="154">Prod</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod" data-verso-hover="154">Prod</span></code> is very much like C#'s tuples, the <code>Pair</code> and <code>Triple</code> types in Kotlin, and <code>tuple</code> in C++.
Many applications are best served by defining their own structures, even for simple cases like <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>, because using domain terminology can make it easier to read the code.
Additionally, defining structure types helps catch more errors by assigning different types to different domain concepts, preventing them from being mixed up.</p>
                <p>
                  On the other hand, there are some cases where it is not worth the overhead of defining a new type.
Additionally, some libraries are sufficiently generic that there is no more specific concept than “pair”.
Finally, the standard library contains a variety of convenience functions that make it easier to work with the built-in pair type.</p>
                <div class="paragraph">
                  <p>
                    The structure <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Prod" data-verso-hover="153">Prod</span></code> is defined with two type arguments:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-23778">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Prod" data-verso-hover="153">Prod</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35064" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35066" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-23824">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-StdLibNoUni.Prod.fst" data-verso-hover="155">fst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35064" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-StdLibNoUni.Prod.snd" data-verso-hover="156">snd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35066" data-verso-hover="113">β</span></code></div>
                <div class="paragraph">
                  <p>
                    Lists are used so frequently that there is special syntax to make them more readable.
For the same reason, both the product type and its constructor have special syntax.
The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod" data-verso-hover="154">Prod</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96502" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96504" data-verso-hover="113">β</span></code> is typically written <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96502" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96504" data-verso-hover="113">β</span></code>, mirroring the usual notation for a Cartesian product of sets.
Similarly, the usual mathematical notation for pairs is available for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Prod" data-verso-hover="154">Prod</span></code>.
In other words, instead of writing:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28590">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-StructNotation.fives" data-verso-hover="157">fives</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Prod.fst" data-verso-hover="158">fst</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="159">"five"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Prod.snd" data-verso-hover="160">snd</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="27">5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                    it suffices to write:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28711">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-fives" data-verso-hover="157">fives</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="159">"five"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="27">5</span><span class="unknown token" data-binding="">)</span></code></div>
                <div class="paragraph">
                  <p>
                    Both notations are right-associative.
This means that the following definitions are equivalent:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28983">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-sevens" data-verso-hover="161">sevens</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="162">"VII"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="27">7</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-28866">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nested.sevens" data-verso-hover="161">sevens</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="162">"VII"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="27">7</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><p>
                    In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes.</p>
                  </div>
                </section>
              <section>
                <h3 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes--Sum">
                  1.6.3.3. <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span></code></h3>
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span></code> datatype is a generic way of allowing a choice between values of two different types.
For instance, a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum" data-verso-hover="163">Sum</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code> is either a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code> or an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code>.
Like <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Prod" data-verso-hover="153">Prod</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span></code> should be used either when writing very generic code, for a very small section of code where there is no sensible domain-specific type, or when the standard library contains useful functions.
In most situations, it is more readable and maintainable to use a custom inductive type.</p>
                <div class="paragraph">
                  <p>
                    Values of type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36327" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36329" data-verso-hover="113">β</span></code> are either the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum.inl" data-verso-hover="164">inl</span></code> applied to a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.35792" data-verso-hover="113">α</span></code> or the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum.inr" data-verso-hover="165">inr</span></code> applied to a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.35794" data-verso-hover="113">β</span></code>:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-24418" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35792" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.35794" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-24463">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Sum.inl" data-verso-hover="164">inl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35792" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35792" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35794" data-verso-hover="113">β</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Sum.inr" data-verso-hover="165">inr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35794" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35792" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35794" data-verso-hover="113">β</span></code><p>
                    These names are abbreviations for “left injection” and “right injection”, respectively.
Just as the Cartesian product notation is used for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Prod" data-verso-hover="153">Prod</span></code>, a “circled plus” notation is used for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum" data-verso-hover="163">Sum</span></code>, so <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="113">β</span></code> is another way to write <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum" data-verso-hover="163">Sum</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96526" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96528" data-verso-hover="113">β</span></code>.
There is no special syntax for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum.inl" data-verso-hover="164">Sum.inl</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum.inr" data-verso-hover="165">Sum.inr</span></code>.</p>
                  </div>
                <div class="paragraph">
                  <p>
                    As an example, if pet names can either be dog names or cat names, then a type for them can be introduced as a sum of strings:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25296">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-PetName" data-verso-hover="166">PetName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code><p>
                    In a real program, it would usually be better to define a custom inductive datatype for this purpose with informative constructor names.
Here, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span></code> is to be used for dog names, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inr" data-verso-hover="168">Sum.inr</span></code> is to be used for cat names.
These constructors can be used to write a list of animal names:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25441">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-animals" data-verso-hover="169">animals</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-PetName" data-verso-hover="166">PetName</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="170">"Spot"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sum.inr" data-verso-hover="168">Sum.inr</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="171">"Tiger"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="172">"Fifi"</span><span class="unknown token" data-binding="">,</span><span class="inter-text">
</span><span class="inter-text">   </span><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="173">"Rex"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sum.inr" data-verso-hover="168">Sum.inr</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="174">"Floof"</span><span class="unknown token" data-binding="">]</span></code></div>
                <div class="paragraph">
                  <p>
                    Pattern matching can be used to distinguish between the two constructors.
For instance, a function that counts the number of dogs in a list of animal names (that is, the number of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span></code> constructors) looks like this:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-25605">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-howManyDogs" data-verso-hover="175">howManyDogs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36527" data-verso-hover="176">pets</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-PetName" data-verso-hover="166">PetName</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-25654" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36527" data-verso-hover="176">pets</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-25654" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36584" data-verso-hover="176">morePets</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-howManyDogs" data-verso-hover="175">howManyDogs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36584" data-verso-hover="176">morePets</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Sum.inr" data-verso-hover="168">Sum.inr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36664" data-verso-hover="176">morePets</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-howManyDogs" data-verso-hover="175">howManyDogs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36664" data-verso-hover="176">morePets</span></code><p>
                    Function calls are evaluated before infix operators, so <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-howManyDogs" data-verso-hover="175">howManyDogs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36874" data-verso-hover="176">morePets</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code> is the same as <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-howManyDogs" data-verso-hover="175">howManyDogs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.36874" data-verso-hover="176">morePets</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>.
As expected, <code class="hl lean inline" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">3</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-26048" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-howManyDogs" data-verso-hover="175">howManyDogs</span><span class="inter-text"> </span><span class="const token" data-binding="const-animals" data-verso-hover="169">animals</span></code> yields <code>3</code>.</p>
                  </div>
                </section>
              <section>
                <h3 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes--Unit">
                  1.6.3.4. <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span></code></h3>
                <div class="paragraph">
                  <p>
                    <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span></code> is a type with just one argumentless constructor, called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Unit.unit" data-verso-hover="177">unit</span></code>.
In other words, it describes only a single value, which consists of said constructor applied to no arguments whatsoever.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span></code> is defined as follows:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-24879" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-24901">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Unit.unit" data-verso-hover="177">unit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span></code></div>
                <div class="paragraph">
                  <p>
                    On its own, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span></code> is not particularly useful.
However, in polymorphic code, it can be used as a placeholder for data that is missing.
For instance, the following inductive datatype represents arithmetic expressions:</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-26226" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-26266">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr.int" data-verso-hover="179">int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr.plus" data-verso-hover="180">plus</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr.minus" data-verso-hover="181">minus</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr.times" data-verso-hover="182">times</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span></code><p>
                    The type argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.37029" data-verso-hover="113">ann</span></code> stands for annotations, and each constructor is annotated.
Expressions coming from a parser might be annotated with source locations, so a return type of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="const token" data-binding="const-SourcePos" data-verso-hover="183">SourcePos</span></code> ensures that the parser put a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-SourcePos" data-verso-hover="183">SourcePos</span></code> at each subexpression.
Expressions that don't come from the parser, however, will not have source locations, so their type can be <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-ArithExpr" data-verso-hover="178">ArithExpr</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.</p>
                  </div>
                <p>
                  Additionally, because all Lean functions have arguments, zero-argument functions in other languages can be represented as functions that take a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> argument.
In a return position, the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> type is similar to <code>void</code> in languages derived from C.
In the C family, a function that returns <code>void</code> will return control to its caller, but it will not return any interesting value.
By being an intentionally uninteresting value, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> allows this to be expressed without requiring a special-purpose <code>void</code> feature in the type system.
Unit's constructor can be written as empty parentheses: <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.</p>
                </section>
              <section>
                <h3 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes--Empty">
                  1.6.3.5. <code>Empty</code></h3>
                <p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Empty" data-verso-hover="185">Empty</span></code> datatype has no constructors whatsoever.
Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Empty" data-verso-hover="185">Empty</span></code>.</p>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Empty" data-verso-hover="185">Empty</span></code> is not used nearly as often as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.
However, it is useful in some specialized contexts.
Many polymorphic datatypes do not use all of their type arguments in all of their constructors.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inr" data-verso-hover="168">Sum.inr</span></code> each use only one of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum" data-verso-hover="163">Sum</span></code>'s type arguments.
Using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Empty" data-verso-hover="185">Empty</span></code> as one of the type arguments to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum" data-verso-hover="163">Sum</span></code> can rule out one of the constructors at a particular point in a program.
This can allow generic code to be used in contexts that have additional restrictions.</p>
                </section>
              <section>
                <h3 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--More-Built-In-Datatypes--Naming___-Sums___-Products___-and-Units">
                  1.6.3.6. Naming: Sums, Products, and Units</h3>
                <p>
                  Generally speaking, types that offer multiple constructors are called <em>sum types</em>, while types whose single constructor takes multiple arguments are called <span id="--tech-term-product-types" class="def-technical-term"><em>product types</em></span>.
These terms are related to sums and products used in ordinary arithmetic.
The relationship is easiest to see when the types involved contain a finite number of values.
If <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96558" data-verso-hover="113">α</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96560" data-verso-hover="113">β</span></code> are types that contain <code class="math inline">n</code> and <code class="math inline">k</code> distinct values, respectively, then <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96558" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96560" data-verso-hover="113">β</span></code> contains <code class="math inline">n + k</code> distinct values and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.96558" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96560" data-verso-hover="113">β</span></code> contains <code class="math inline">n \times k</code> distinct values.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span></code> has two values: <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.true" data-verso-hover="97">true</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.false" data-verso-hover="19">false</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Unit" data-verso-hover="1">Unit</span></code> has one value: <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit.unit" data-verso-hover="186">Unit.unit</span></code>.
The product <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> has the two values <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit.unit" data-verso-hover="186">Unit.unit</span><span class="unknown token" data-binding="">)</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit.unit" data-verso-hover="186">Unit.unit</span><span class="unknown token" data-binding="">)</span></code>, and the sum <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> has the three values <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inl" data-verso-hover="167">Sum.inl</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Sum.inr" data-verso-hover="168">Sum.inr</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit.unit" data-verso-hover="186">Unit.unit</span></code>.
Similarly, <code class="math inline">2 \times 1 = 2</code>, and <code class="math inline">2 + 1 = 3</code>.</p>
                </section>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Messages-You-May-Meet">
                1.6.4. Messages You May Meet</h2>
              <div class="paragraph">
                <p>
                  Not all definable structures or inductive types can have the type <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="50">Type</span></code>.
In particular, if a constructor takes an arbitrary type as an argument, then the inductive type must have a different type.
These errors usually state something about “universe levels”.
For example, for this inductive type:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-31933" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="187">MyType</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-31957">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid universe level in constructor 'MyType.ctor', parameter 'α' has type
  Type
at universe level
  2
which is not less than or equal to the inductive type's resulting universe level
  1</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ctor</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56060" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56060" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="187">MyType</span></span></code><p>
                  Lean gives the following error:</p>
                <div class="error">
                  <pre>invalid universe level in constructor 'MyType.ctor', parameter 'α' has type
  Type
at universe level
  2
which is not less than or equal to the inductive type's resulting universe level
  1</pre></div>
                <p>
                  A later chapter describes why this is the case, and how to modify definitions to make them work.
For now, try making the type an argument to the inductive type as a whole, rather than to the constructor.</p>
                </div>
              <div class="paragraph">
                <p>
                  Similarly, if a constructor's argument is a function that takes the datatype being defined as an argument, then the definition is rejected.
For example:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) arg #1 of 'MyType.ctor' has a non positive occurrence of the datatypes being declared</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-32178" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="187">MyType</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-32202">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ctor</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-MyType" data-verso-hover="187">MyType</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="187">MyType</span></span></code><p>
                  yields the message:</p>
                <div class="error">
                  <pre>(kernel) arg #1 of 'MyType.ctor' has a non positive occurrence of the datatypes being declared</pre></div>
                <p>
                  For technical reasons, allowing these datatypes could make it possible to undermine Lean's internal logic, making it unsuitable for use as a theorem prover.</p>
                </div>
              <div class="paragraph">
                <p>
                  Recursive functions that take two parameters should not match against the pair, but rather match each parameter independently.
Otherwise, the mechanism in Lean that checks whether recursive calls are made on smaller values is unable to see the connection between the input value and the argument in the recursive call.
For example, this function that determines whether two lists have the same length is rejected:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34079">def</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">fail to show termination for
  sameLength
with errors
failed to infer structural recursion:
Not considering parameter α of sameLength:
  it is unchanged in the recursive calls
Not considering parameter β of sameLength:
  it is unchanged in the recursive calls
Cannot use parameter xs:
  failed to eliminate recursive application
    sameLength xs' ys'
Cannot use parameter ys:
  failed to eliminate recursive application
    sameLength xs' ys'


Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
              xs ys
1) 1763:28-46  ?  ?
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="const token" data-binding="const-sameLength" data-verso-hover="188">sameLength</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56895" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96816" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56898" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96818" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34136" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56895" data-verso-hover="137">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56898" data-verso-hover="189">ys</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34136" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56978" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56979" data-verso-hover="137">xs'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56980" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56981" data-verso-hover="189">ys'</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-sameLength" data-verso-hover="188">sameLength</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56979" data-verso-hover="137">xs'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56981" data-verso-hover="189">ys'</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code><p>
                  The error message is:</p>
                <div class="error">
                  <pre>fail to show termination for
  sameLength
with errors
failed to infer structural recursion:
Not considering parameter α of sameLength:
  it is unchanged in the recursive calls
Not considering parameter β of sameLength:
  it is unchanged in the recursive calls
Cannot use parameter xs:
  failed to eliminate recursive application
    sameLength xs' ys'
Cannot use parameter ys:
  failed to eliminate recursive application
    sameLength xs' ys'


Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
              xs ys
1) 1763:28-46  ?  ?
Please use `termination_by` to specify a decreasing measure.</pre></div>
                <p>
                  The problem can be fixed through nested pattern matching:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34312">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nested.sameLength" data-verso-hover="188">sameLength</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83989" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96816" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.83992" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96818" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34369" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83989" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34369" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34397" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83992" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34397" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84099" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84100" data-verso-hover="137">xs'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34465" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.83992" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34465" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84119" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84120" data-verso-hover="189">ys'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nested.sameLength" data-verso-hover="188">sameLength</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84100" data-verso-hover="137">xs'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84120" data-verso-hover="189">ys'</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code><p>
                  <a href="Getting-to-Know-Lean/Additional-Conveniences/#simultaneous-matching">Simultaneous matching</a>, described in the next section, is another way to solve the problem that is often more elegant.</p>
                </div>
              <div class="paragraph">
                <p>
                  Forgetting an argument to an inductive type can also yield a confusing message.
For example, when the argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.56241" data-verso-hover="113">α</span></code> is not passed to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MyType" data-verso-hover="191">MyType</span></code> in <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">ctor</span></code>'s type:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-32467" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="191">MyType</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56241" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-32503">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ctor</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56241" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type expected, got
  (MyType : Type → Type)</code></span></span><span class="const token" data-binding="const-MyType" data-verso-hover="191">MyType</span></span></code><p>
                  Lean replies with the following error:</p>
                <div class="error">
                  <pre>type expected, got
  (MyType : Type → Type)</pre></div>
                <p>
                  The error message is saying that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MyType" data-verso-hover="191">MyType</span></code>'s type, which is <code class="hl lean inline" data-lean-context="examples"><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span></code>, does not itself describe types.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MyType" data-verso-hover="191">MyType</span></code> requires an argument to become an actual honest-to-goodness type.</p>
                </div>
              <div class="paragraph">
                <p>
                  The same message can appear when type arguments are omitted in other contexts, such as in a type signature for a definition:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-32588" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="192">MyType</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56258" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-32624">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType.ctor" data-verso-hover="193">ctor</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56258" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-MyType" data-verso-hover="192">MyType</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56258" data-verso-hover="113">α</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-32973">def</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ofFive</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type expected, got
  (MyType : Type → Type)</code></span></span><span class="const token" data-binding="const-MyType" data-verso-hover="192">MyType</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">ctor</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5</span></code><div class="error">
                  <pre>type expected, got
  (MyType : Type → Type)</pre></div>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Polymorphism--Exercises">
                1.6.5. Exercises</h2>
              <ul>
                <li>
                  <p>
                    Write a function to find the last entry in a list. It should return an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Write a function that finds the first entry in a list that satisfies a given predicate. Start the definition with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-48420">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List.findFirst?" data-verso-hover="194">List.findFirst?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.96152" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96154" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96152" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96158" data-verso-hover="195">predicate</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96152" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96152" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Write a function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.Prod.switch" data-verso-hover="196">Prod.switch</span></code> that switches the two fields in a pair for each other. Start the definition with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-48598">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.Prod.switch" data-verso-hover="196">Prod.switch</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.96186" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96188" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96192" data-verso-hover="197">pair</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96186" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96188" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96188" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96186" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Rewrite the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-PetName" data-verso-hover="166">PetName</span></code> example to use a custom datatype and compare it to the version that uses <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-StdLibNoUni.Sum" data-verso-hover="0">Sum</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Write a function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.zip" data-verso-hover="198">zip</span></code> that combines two lists into a list of pairs. The resulting list should be as long as the shortest input list. Start the definition with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-48735">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.zip" data-verso-hover="198">zip</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.96220" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96222" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96224" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96220" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96226" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96222" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.List" data-verso-hover="128">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.96220" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96222" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">…</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Write a polymorphic function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-take" data-verso-hover="199">take</span></code> that returns the first <code class="math inline">n</code> entries in a list, where <code class="math inline">n</code> is a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>. If the list contains fewer than <code class="math inline">n</code> entries, then the resulting list should be the entire input list. <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-30904" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-take" data-verso-hover="199">take</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="200">"bolete"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="201">"oyster"</span><span class="unknown token" data-binding="">]</span></code> should yield <code>["bolete", "oyster"]</code>, and <code class="hl lean inline" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">["bolete"]</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-31022" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-take" data-verso-hover="199">take</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="200">"bolete"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="201">"oyster"</span><span class="unknown token" data-binding="">]</span></code> should yield <code>["bolete"]</code>.</p>
                  </li>
                <li>
                  <p>
                    Using the analogy between types and arithmetic, write a function that distributes products over sums. In other words, it should have type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.95521" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.95523" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95525" data-verso-hover="113">γ</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.95521" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95523" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.95521" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95525" data-verso-hover="113">γ</span><span class="unknown token" data-binding="">)</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Using the analogy between types and arithmetic, write a function that turns multiplication by two into a sum. In other words, it should have type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95521" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95521" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⊕</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.95521" data-verso-hover="113">α</span></code>.
</p>
                  </li>
                </ul>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns" rel="prev" title="1.5. Datatypes and Patterns"><span class="arrow">←</span><span class="where">1.5. Datatypes and Patterns</span></a><a class="local-button active" href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences" rel="next" title="1.7. Additional Conveniences"><span class="where">1.7. Additional Conveniences</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

