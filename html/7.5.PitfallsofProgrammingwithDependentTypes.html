<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Pitfalls of Programming with Dependent Types</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="current numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-Functional-Programming-in-Lean--Programming-with-Dependent-Types" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-Functional-Programming-in-Lean--Programming-with-Dependent-Types" checked="checked"></label><span class="number">7.</span> <span class=""><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></span></div>
              <table><tr class="numbered"><td class="num">7.1.</td><td><a href="Programming-with-Dependent-Types/Indexed-Families/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Indexed-Families">Indexed Families</a></td></tr><tr class="numbered"><td class="num">7.2.</td><td><a href="Programming-with-Dependent-Types/The-Universe-Design-Pattern/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--The-Universe-Design-Pattern">The Universe Design Pattern</a></td></tr><tr class="numbered"><td class="num">7.3.</td><td><a href="Programming-with-Dependent-Types/Worked-Example___-Typed-Queries/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Worked-Example___-Typed-Queries">Worked Example: Typed Queries</a></td></tr><tr class="numbered"><td class="num">7.4.</td><td><a href="Programming-with-Dependent-Types/Indices___-Parameters___-and-Universe-Levels/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Indices___-Parameters___-and-Universe-Levels">Indices, Parameters, and Universe Levels</a></td></tr><tr class="current numbered"><td class="num">7.5.</td><td><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types">Pitfalls of Programming with Dependent Types</a></td></tr><tr class="numbered"><td class="num">7.6.</td><td><a href="Programming-with-Dependent-Types/Summary/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types" checked="checked"></label><span class="number">7.5.</span> <span class="current"><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types">Pitfalls of Programming with Dependent Types</a></span></div>
              <table><tr class="numbered"><td class="num">7.5.1.</td><td><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Definitional-Equality">Definitional Equality</a></td></tr><tr class="numbered"><td class="num">7.5.2.</td><td><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Getting-Stuck-on-Addition">Getting Stuck on Addition</a></td></tr><tr class="numbered"><td class="num">7.5.3.</td><td><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Propositional-Equality">Propositional Equality</a></td></tr><tr class="numbered"><td class="num">7.5.4.</td><td><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Pros-and-Cons">Pros and Cons</a></td></tr><tr class="numbered"><td class="num">7.5.5.</td><td><a href="Programming-with-Dependent-Types/Pitfalls-of-Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Exercises">Exercises</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Programming-with-Dependent-Types/Indices___-Parameters___-and-Universe-Levels/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Indices___-Parameters___-and-Universe-Levels" rel="prev" title="7.4. Indices, Parameters, and Universe Levels"><span class="arrow">←</span><span class="where">7.4. Indices, Parameters, and Universe Levels</span></a><a class="local-button active" href="Programming-with-Dependent-Types/Summary/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Summary" rel="next" title="7.6. Summary"><span class="where">7.6. Summary</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              7.5. Pitfalls of Programming with Dependent Types</h1>
            <p>
              The flexibility of dependent types allows more useful programs to be accepted by a type checker, because the language of types is expressive enough to describe variations that less-expressive type systems cannot.
At the same time, the ability of dependent types to express very fine-grained specifications allows more buggy programs to be rejected by a type checker.
This power comes at a cost.</p>
            <p>
              The close coupling between the internals of type-returning functions such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Row" data-verso-hover="1656">Row</span></code> and the types that they produce is an instance of a bigger difficulty: the distinction between the interface and the implementation of functions begins to break down when functions are used in types.
Normally, all refactorings are valid as long as they don't change the type signature or input-output behavior of a function.
Functions can be rewritten to use more efficient algorithms and data structures, bugs can be fixed, and code clarity can be improved without breaking client code.
When the function is used in a type, however, the internals of the function's implementation become part of the type, and thus part of the <em>interface</em> to another program.</p>
            <p>
              As an example, take the following two implementations of addition on <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span></code> is recursive on its first argument:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-113">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="5">k</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code><p>
              <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span></code>, on the other hand, is recursive on its second argument:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-233">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.362" data-verso-hover="5">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.362" data-verso-hover="5">n</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.442" data-verso-hover="5">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.443" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.442" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.443" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code><p>
              Both implementations of addition are faithful to the underlying mathematical concept, and they thus return the same result when given the same arguments.</p>
            <p>
              However, these two implementations present quite different interfaces when they are used in types.
As an example, take a function that appends two <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code>s.
This function should return a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> whose length is the sum of the length of the arguments.
Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> is essentially a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span></code> with a more informative type, it makes sense to write the function just as one would for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.append" data-verso-hover="631">List.append</span></code>, with pattern matching and recursion on the first argument.
Starting with a type signature and initial pattern match pointing at placeholders yields two messages:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-676">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendL" data-verso-hover="1820">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.706" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.712" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.706" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.721" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.706" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.712" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.721" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.734" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusL 0 k)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.884" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.885" data-verso-hover="1580">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.886" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k n✝ : Nat
x : α
xs : Vect α n✝
ys : Vect α k
⊢ Vect α ((n✝ + 1).plusL k)</code></span></span><span class="unknown token" data-binding="">_</span></span></code><p>
              The first message, in the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.nil" data-verso-hover="133">nil</span></code> case, states that the placeholder should be replaced by a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> with length <code>plusL 0 k</code>:</p>
            <div class="error">
              <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusL 0 k)</pre></div>
            <p>
              The second message, in the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.cons" data-verso-hover="132">cons</span></code> case, states that the placeholder should be replaced by a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> with length <code>plusL (n✝ + 1) k</code>:</p>
            <div class="error">
              <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k n✝ : Nat
x : α
xs : Vect α n✝
ys : Vect α k
⊢ Vect α ((n✝ + 1).plusL k)</pre></div>
            <p>
              The symbol after <code>n</code>, called a <em>dagger</em>, is used to indicate names that Lean has internally invented.
Behind the scenes, pattern matching on the first <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> implicitly caused the value of the first <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> to be refined as well, because the index on the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.cons" data-verso-hover="132">cons</span></code> is <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.215" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>, with the tail of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> having length <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.215" data-verso-hover="5">n</span></code>.
Here, <code>n✝</code> represents the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> that is one less than the argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.712" data-verso-hover="5">n</span></code>.</p>
            <section>
              <h2 id="Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Definitional-Equality">
                7.5.1. Definitional Equality</h2>
              <p>
                In the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code>, there is a pattern case <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.35" data-verso-hover="5">k</span></code>.
This applies in the length used in the first placeholder, so another way to write the underscore's type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14952" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14955" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code> is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14952" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14955" data-verso-hover="5">k</span></code>.
Similarly, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code> contains a pattern case <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.115" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.115" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.116" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>.
This means that the type of the second underscore can be equivalently written <code>Vect α (plusL n✝ k + 1)</code>.</p>
              <p>
                To expose what is going on behind the scenes, the first step is to write the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> arguments explicitly, which also results in daggerless error messages because the names are now written explicitly in the program:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1633">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendL" data-verso-hover="1821">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1568" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1570" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1565" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1568" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1565" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1570" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1565" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1568" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1570" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1633" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1634" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusL 0 k)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1741" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1742" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1743" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1744" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1745" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusL k)</code></span></span><span class="unknown token" data-binding="">_</span></span></code><div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusL 0 k)</pre></div>
              <div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusL k)</pre></div>
              <p>
                Annotating the underscores with the simplified versions of the types does not introduce a type error, which means that the types as written in the program are equivalent to the ones that Lean found on its own:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2625">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendL" data-verso-hover="1821">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2716" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2718" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2713" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2716" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2713" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2718" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2713" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2716" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2718" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2781" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2782" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α k</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2730" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2781" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2898" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2899" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2900" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2901" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2902" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (n.plusL k + 1)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2730" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2898" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2899" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α k</pre></div>
              <div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (n.plusL k + 1)</pre></div>
              <p>
                The first case demands a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2713" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2718" data-verso-hover="5">k</span></code>, and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2782" data-verso-hover="1584">ys</span></code> has that type.
This is parallel to the way that appending the empty list to any other list returns that other list.
Refining the definition with <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.4034" data-verso-hover="1584">ys</span></code> instead of the first underscore yields a program with only one remaining underscore to be filled out:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3573">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendL" data-verso-hover="1821">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3968" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3970" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3965" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3968" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3965" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3970" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3965" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3968" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3970" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4033" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4034" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4034" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4148" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4149" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4150" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4151" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4152" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (n.plusL k + 1)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.3982" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4148" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4149" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (n.plusL k + 1)</pre></div>
              <p>
                Something very important has happened here.
In a context where Lean expected a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14952" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14955" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code>, it received a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14952" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14955" data-verso-hover="5">k</span></code>.
However, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span></code> is not an <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">abbrev</span></code>, so it may seem like it shouldn't be running during type checking.
Something else is happening.</p>
              <p>
                The key to understanding what's going on is that Lean doesn't just expand <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">abbrev</span></code>s while type checking.
It can also perform computation while checking whether two types are equivalent to one another, such that any expression of one type can be used in a context that expects the other type.
This property is called <em>definitional equality</em>, and it is subtle.</p>
              <p>
                Certainly, two types that are written identically are considered to be definitionally equal—<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code> should be considered equal.
Any two concrete types built from different datatypes are not equal, so <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> is not equal to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code>.
Additionally, types that differ only by renaming internal names are equal, so <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span></code> is the same as <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14524" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14524" data-verso-hover="5">k</span></code>.
Because types can contain ordinary data, definitional equality must also describe when data are equal.
Uses of the same constructors are equal, so <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span></code> equals <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">]</span></code> equals <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">[</span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">]</span></code>.</p>
              <p>
                Types contain more than just function arrows, datatypes, and constructors, however.
They also contain <em>variables</em> and <em>functions</em>.
Definitional equality of variables is relatively simple: each variable is equal only to itself, so <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14617" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14619" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14617" data-verso-hover="5">n</span></code> is not definitionally equal to <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14628" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14630" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14630" data-verso-hover="5">k</span></code>.
Functions, on the other hand, are more complicated.
While mathematics considers two functions to be equal if they have identical input-output behavior, there is no efficient algorithm to check that, and the whole point of definitional equality is for Lean to check whether two types are interchangeable.
Instead, Lean considers functions to be definitionally equal either when they are both <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">fun</span></code>-expressions with definitionally equal bodies.
In other words, two functions must use <em>the same algorithm</em> that calls <em>the same helpers</em> to be considered definitionally equal.
This is not typically very helpful, so definitional equality of functions is mostly used when the exact same defined function occurs in two types.</p>
              <p>
                When functions are <em>called</em> in a type, checking definitional equality may involve reducing the function call.
The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">4</span><span class="unknown token" data-binding="">)</span></code> is definitionally equal to the type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="unknown token" data-binding="">)</span></code> because <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">4</span></code> is definitionally equal to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span></code>.
To check their equality, both are reduced to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">5</span></code>, and then the constructor rule can be used five times.
Definitional equality of functions applied to data can be checked first by seeing if they're already the same—there's no need to reduce <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="793">"a"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="794">"b"</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">++</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="795">"c"</span><span class="unknown token" data-binding="">]</span></code> to check that it's equal to <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="793">"a"</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="794">"b"</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">++</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="795">"c"</span><span class="unknown token" data-binding="">]</span></code>, after all.
If not, the function is called and replaced with its value, and the value can then be checked.</p>
              <p>
                Not all function arguments are concrete data.
For example, types may contain <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>s that are not built from the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">zero</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">succ</span></code> constructors.
In the type <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span></code>, the variable <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span></code> is a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, but it is impossible to know <em>which</em> <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> it is before the function is called.
Indeed, the function may be called first with <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span></code>, and then later with <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">17</span></code>, and then again with <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">33</span></code>.
As seen in the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-appendL" data-verso-hover="1820">appendL</span></code>, variables with type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> may also be passed to functions such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code>.
Indeed, the type <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span></code> is definitionally equal to the type <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14546" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14546" data-verso-hover="5">n</span><span class="unknown token" data-binding="">)</span></code>.</p>
              <p>
                The reason that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14546" data-verso-hover="5">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14546" data-verso-hover="5">n</span></code> are definitionally equal is that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code>'s pattern match examines its <em>first</em> argument.
This is problematic: <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14520" data-verso-hover="5">n</span></code> is <em>not</em> definitionally equal to <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14564" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14564" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">)</span></code>, even though zero should be both a left and a right identity of addition.
This happens because pattern matching gets stuck when it encounters variables.
Until the actual value of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14564" data-verso-hover="5">n</span></code> becomes known, there is no way to know which case of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">Nat.plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14564" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span></code> should be selected.</p>
              <p>
                The same issue appears with the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Row" data-verso-hover="1656">Row</span></code> function in the query example.
The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Row" data-verso-hover="1656">Row</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2318" data-verso-hover="1657">c</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.2321" data-verso-hover="1658">cs</span><span class="unknown token" data-binding="">)</span></code> does not reduce to any datatype because the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Row" data-verso-hover="1656">Row</span></code> has separate cases for singleton lists and lists with at least two entries.
In other words, it gets stuck when trying to match the variable <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.2321" data-verso-hover="1658">cs</span></code> against concrete <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span></code> constructors.
This is why almost every function that takes apart or constructs a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Row" data-verso-hover="1656">Row</span></code> needs to match the same three cases as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Row" data-verso-hover="1656">Row</span></code> itself: getting it unstuck reveals concrete types that can be used for either pattern matching or constructors.</p>
              <p>
                The missing case in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-appendL" data-verso-hover="1821">appendL</span></code> requires a <code>Vect α (Nat.plusL n k + 1)</code>.
The <code>+ 1</code> in the index suggests that the next step is to use <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">Vect.cons</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-3974">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendL" data-verso-hover="1821">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4591" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4593" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4588" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4591" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4588" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4593" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4588" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4591" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4593" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4656" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4657" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4657" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4771" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4772" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4773" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4774" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4775" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4773" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (n.plusL k)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4605" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4771" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.4772" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α (n.plusL k)</pre></div>
              <p>
                A recursive call to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Almost.appendL" data-verso-hover="1821">appendL</span></code> can construct a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> with the desired length:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4222">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Almost.appendL" data-verso-hover="1821">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5196" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5198" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5193" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5196" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5193" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5198" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5193" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5196" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5198" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5261" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5262" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5262" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5376" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5377" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5378" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5379" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5380" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5378" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Almost.appendL" data-verso-hover="1821">appendL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5376" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5377" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5379" data-verso-hover="1822">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5380" data-verso-hover="1584">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                Now that the program is finished, removing the explicit matching on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.5196" data-verso-hover="5">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.5198" data-verso-hover="5">k</span></code> makes it easier to read and easier to call the function:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4442">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendL" data-verso-hover="1820">appendL</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5977" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5983" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5977" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5992" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5977" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5983" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5992" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6005" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6005" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6162" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6163" data-verso-hover="1580">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6005" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6162" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-appendL" data-verso-hover="1820">appendL</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6163" data-verso-hover="1580">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6005" data-verso-hover="1584">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                Comparing types using definitional equality means that everything involved in definitional equality, including the internals of function definitions, becomes part of the <em>interface</em> of programs that use dependent types and indexed families.
Exposing the internals of a function in a type means that refactoring the exposed program may cause programs that use it to no longer type check.
In particular, the fact that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code> is used in the type of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-appendL" data-verso-hover="1820">appendL</span></code> means that the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code> cannot be replaced by the otherwise-equivalent <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code>.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Getting-Stuck-on-Addition">
                7.5.2. Getting Stuck on Addition</h2>
              <p>
                What happens if append is defined with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code> instead?
Beginning in the same way, with explicit lengths and placeholder underscores in each case, reveals the following useful error messages:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-4920">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6612" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6614" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6609" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6612" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6609" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6614" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6609" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6612" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6614" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6677" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6678" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusR 0 k)</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6785" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6786" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6787" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6788" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6789" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusR k)</code></span></span><span class="unknown token" data-binding="">_</span></span></code><div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α (Nat.plusR 0 k)</pre></div>
              <div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusR k)</pre></div>
              <p>
                However, attempting to place a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7757" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7762" data-verso-hover="5">k</span></code> type annotation around the first placeholder results in an type mismatch error:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5791">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7760" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7762" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7757" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7760" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7757" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7762" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7757" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7760" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7762" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type mismatch
  ?m.7829
has type
  Vect α k : Type ?u.7765
but is expected to have type
  Vect α (Nat.plusR 0 k) : Type ?u.7765</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7825" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7826" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7774" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.7825" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8074" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8075" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8076" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8077" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8078" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code><div class="error">
                <pre>type mismatch
  ?m.7829
has type
  Vect α k : Type ?u.7765
but is expected to have type
  Vect α (Nat.plusR 0 k) : Type ?u.7765</pre></div>
              <p>
                This error is pointing out that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14985" data-verso-hover="5">k</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14985" data-verso-hover="5">k</span></code> are <em>not</em> definitionally equal.</p>
              <div class="paragraph">
                <p>
                  This is because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code> has the following definition:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-233">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.362" data-verso-hover="5">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.362" data-verso-hover="5">n</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.442" data-verso-hover="5">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.443" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.442" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.443" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code><p>
                  Its pattern matching occurs on the <em>second</em> argument, not the first argument, which means that the presence of the variable <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.14985" data-verso-hover="5">k</span></code> in that position prevents it from reducing.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.add" data-verso-hover="394">Nat.add</span></code> in Lean's standard library is equivalent to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code>, not <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code>, so attempting to use it in this definition results in precisely the same difficulties:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6164">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendR" data-verso-hover="1824">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8474" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8476" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8471" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8474" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8471" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8476" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8471" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8474" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8476" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">type mismatch
  ?m.8578
has type
  Vect α k : Type ?u.8479
but is expected to have type
  Vect α (0 + k) : Type ?u.8479</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8574" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8575" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8523" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8574" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8802" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8803" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8804" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8805" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.8806" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span></code><div class="error">
                  <pre>type mismatch
  ?m.8578
has type
  Vect α k : Type ?u.8479
but is expected to have type
  Vect α (0 + k) : Type ?u.8479</pre></div>
                <p>
                  Addition is getting <em>stuck</em> on the variables.
Getting it unstuck requires <a href="Overloading-and-Type-Classes/Standard-Classes/#equality-and-ordering">propositional equality</a>.</p>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Propositional-Equality">
                7.5.3. Propositional Equality</h2>
              <p>
                Propositional equality is the mathematical statement that two expressions are equal.
While definitional equality is a kind of ambient fact that Lean automatically checks when required, statements of propositional equality require explicit proofs.
Once an equality proposition has been proved, it can be used in a program to modify a type, replacing one side of the equality with the other, which can unstick the type checker.</p>
              <p>
                The reason why definitional equality is so limited is to enable it to be checked by an algorithm.
Propositional equality is much richer, but the computer cannot in general check whether two expressions are propositionally equal, though it can verify that a purported proof is in fact a proof.
The split between definitional and propositional equality represents a division of labor between humans and machines: the most boring equalities are checked automatically as part of definitional equality, freeing the human mind to work on the interesting problems available in propositional equality.
Similarly, definitional equality is invoked automatically by the type checker, while propositional equality must be specifically appealed to.</p>
              <p>
                In <a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Propositions, Proofs, and Indexing</a>, some equality statements are proved using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">decide</span></code>.
All of these equality statements are ones in which the propositional equality is in fact already a definitional equality.
Typically, statements of propositional equality are proved by first getting them into a form where they are either definitional or close enough to existing proved equalities, and then using tools like <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">decide</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">simp</span></code> to take care of the simplified cases.
The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">simp</span></code> tactic is quite powerful: behind the scenes, it uses a number of fast, automated tools to construct a proof.
A simpler tactic called <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">rfl</span></code> specifically uses definitional equality to prove propositional equality.
The name <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">rfl</span></code> is short for <em>reflexivity</em>, which is the property of equality that states that everything equals itself.</p>
              <p>
                Unsticking <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span></code> requires a proof that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code>, which is not a definitional equality because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code> is stuck on the variable in its second argument.
To get it to compute, the <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code> must become a concrete constructor.
This is a job for pattern matching.</p>
              <div class="paragraph">
                <p>
                  In particular, because <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code> could be <em>any</em> <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, this task requires a function that can return evidence that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code> for <em>any</em> <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code> whatsoever.
This should be a function that returns a proof of equality, with type <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code>.
Getting it started with initial patterns and placeholders yields the following messages:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-6592">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
⊢ 0 = Nat.plusR 0 0</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9288" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 (k + 1)</code></span></span><span class="unknown token" data-binding="">_</span></span></code><div class="error">
                  <pre>don't know how to synthesize placeholder
context:
⊢ 0 = Nat.plusR 0 0</pre></div>
                <div class="error">
                  <pre>don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 (k + 1)</pre></div>
                <p>
                  Having refined <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9191" data-verso-hover="5">k</span></code> to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span></code> via pattern matching, the first placeholder stands for evidence of a statement that does hold definitionally.
The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">rfl</span></code> tactic takes care of it, leaving only the second placeholder:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7249">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9499" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9499" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9499" data-verso-hover="5">k</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-11699103386578699429-7312-7314"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7312" data-verso-hover="340">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11699103386578699429-7312-7314"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">0</span><span class="const token" data-binding="const-Eq" data-verso-hover="342"> = </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="inter-text"> </span><span class="inter-text">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-7315-7318"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-7315" data-verso-hover="1826">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-7315-7318"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9596" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 (k + 1)</code></span></span><span class="unknown token" data-binding="">_</span></span></code></div>
              <p>
                The second placeholder is a bit trickier.
The expression <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="const token" data-binding="const-Adding.k" data-verso-hover="1827">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code> is definitionally equal to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Adding.k" data-verso-hover="1827">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span></code>.
This means that the goal could also be written <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9896" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9896" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7694">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9799" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9799" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9799" data-verso-hover="5">k</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-11699103386578699429-7757-7759"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7757" data-verso-hover="340">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11699103386578699429-7757-7759"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">0</span><span class="const token" data-binding="const-Eq" data-verso-hover="342"> = </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="inter-text"> </span><span class="inter-text">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-7760-7763"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-7760" data-verso-hover="1826">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-7760-7763"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9896" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 k + 1</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9896" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9896" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span></code><div class="error">
                <pre>don't know how to synthesize placeholder
context:
k : Nat
⊢ k + 1 = Nat.plusR 0 k + 1</pre></div>
              <div class="paragraph">
                <p>
                  Underneath the <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></code> on each side of the equality statement is another instance of what the function itself returns.
In other words, a recursive call on <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9799" data-verso-hover="5">k</span></code> would return evidence that <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.9799" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9799" data-verso-hover="5">k</span></code>.
Equality wouldn't be equality if it didn't apply to function arguments.
In other words, if <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15065" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15067" data-verso-hover="121">y</span></code>, then <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15071" data-verso-hover="565">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15065" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15071" data-verso-hover="565">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15067" data-verso-hover="121">y</span></code>.
The standard library contains a function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-congrArg" data-verso-hover="1828">congrArg</span></code> that takes a function and an equality proof and returns a new proof where the function has been applied to both sides of the equality.
In this case, the function is <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7901">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10053" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10053" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10053" data-verso-hover="5">k</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-11699103386578699429-7964-7966"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-7964" data-verso-hover="340">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11699103386578699429-7964-7966"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">0</span><span class="const token" data-binding="const-Eq" data-verso-hover="342"> = </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="inter-text"> </span><span class="inter-text">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-7967-7970"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-7967" data-verso-hover="1826">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-7967-7970"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10150" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-congrArg" data-verso-hover="1828">congrArg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10150" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code></div>
              <div class="paragraph">
                <p>
                  Because this is really a proof of a proposition, it should be declared as a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">theorem</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-8110">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10360" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10360" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10360" data-verso-hover="5">k</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-11699103386578699429-8177-8179"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8177" data-verso-hover="340">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11699103386578699429-8177-8179"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="inter-text">0</span><span class="const token" data-binding="const-Eq" data-verso-hover="342"> = </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="inter-text"> </span><span class="inter-text">0</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-8180-8183"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-8180" data-verso-hover="1826">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8180-8183"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10457" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-congrArg" data-verso-hover="1828">congrArg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10457" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code></div>
              <p>
                Propositional equalities can be deployed in a program using the rightward triangle operator <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">▸</span></code>.
Given an equality proof as its first argument and some other expression as its second, this operator replaces instances of one side of the equality with the other side of the equality in the second argument's type.
In other words, the following definition contains no type errors:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8592">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10677" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10679" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10674" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10677" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10674" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10679" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10674" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10677" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10679" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10742" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10743" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10742" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α k</code></span></span><span class="unknown token" data-binding="">_</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10691" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10742" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10858" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10859" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10860" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10861" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.10862" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusR k)</code></span></span><span class="unknown token" data-binding="">_</span></span></code><p>
                The first placeholder has the expected type:</p>
              <div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
k : Nat
ys : Vect α k
⊢ Vect α k</pre></div>
              <p>
                It can now be filled in with <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11325" data-verso-hover="1584">ys</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9010">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11259" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11259" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11256" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11259" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11324" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11325" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11324" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11325" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11436" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11437" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11438" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11439" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11440" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusR k)</code></span></span><span class="unknown token" data-binding="">_</span></span></code><p>
                Filling in the remaining placeholder requires unsticking another instance of addition:</p>
              <div class="error">
                <pre>don't know how to synthesize placeholder
context:
α : Type u_1
n k : Nat
x : α
xs : Vect α n
ys : Vect α k
⊢ Vect α ((n + 1).plusR k)</pre></div>
              <p>
                Here, the statement to be proved is that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12297" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12297" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>, which can be used with <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">▸</span></code> to draw the <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></code> out to the top of the expression so that it matches the index of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">cons</span></code>.</p>
              <p>
                The proof is a recursive function that pattern matches on the second argument to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code>, namely <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11261" data-verso-hover="5">k</span></code>.
This is because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code> itself pattern matches on its second argument, so the proof can “unstick” it through pattern matching, exposing the computational behavior.
The skeleton of the proof is very similar to that of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-9387">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11824" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11827" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11824" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11827" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11824" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11827" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-9309669852764618165-9490-9492"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-9490" data-verso-hover="340">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-9309669852764618165-9490-9492"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.11824" data-verso-hover="5">n</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341">(</span><span class="var token" data-binding="var-_uniq.11824" data-verso-hover="5">n</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341"> + </span><span class="inter-text">1</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341">)</span><span class="inter-text">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="const token" data-binding="const-Eq" data-verso-hover="342"> = </span><span class="var token" data-binding="var-_uniq.11824" data-verso-hover="5">n</span><span class="inter-text">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341"> + </span><span class="inter-text">1</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-9493-9496"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-9493" data-verso-hover="1826">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-9493-9496"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11988" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">don't know how to synthesize placeholder
context:
n k : Nat
⊢ (n + 1).plusR (k + 1) = n.plusR (k + 1) + 1</code></span></span><span class="unknown token" data-binding="">_</span></span></code><p>
                The remaining case's type is definitionally equal to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15122" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15125" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15122" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15125" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>, so it can be solved with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-congrArg" data-verso-hover="1828">congrArg</span></code>, just as in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span></code>:</p>
              <div class="error">
                <pre>don't know how to synthesize placeholder
context:
n k : Nat
⊢ (n + 1).plusR (k + 1) = n.plusR (k + 1) + 1</pre></div>
              <p>
                This results in a finished proof:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-9941">theorem</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12297" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12297" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">Nat.plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12297" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-320725224460444196-10044-10046"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-10044" data-verso-hover="340">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-320725224460444196-10044-10046"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341">(</span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341"> + </span><span class="inter-text">1</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341">)</span><span class="inter-text">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="const token" data-binding="const-Eq" data-verso-hover="342"> = </span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="inter-text">0</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="341"> + </span><span class="inter-text">1</span></span></span></span></span></span><span class="inter-text"> </span><span class="tactic"><label for="tactic-state-7-10047-10050"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRfl-10047" data-verso-hover="1826">rfl</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-10047-10050"><span class="tactic-state">All goals completed! 🐙</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12458" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-congrArg" data-verso-hover="1828">congrArg</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12294" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12458" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code><p>
                The finished proof can be used to unstick the second case in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10156">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12690" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12692" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12687" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12690" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12687" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12692" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12687" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12690" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12692" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12755" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12756" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12755" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12756" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12867" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12868" data-verso-hover="5">k</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12869" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12870" data-verso-hover="1822">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12871" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12867" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12868" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12869" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12867" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12868" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12870" data-verso-hover="1822">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12871" data-verso-hover="1584">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                When making the length arguments to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-appendR" data-verso-hover="1823">appendR</span></code> implicit again, they are no longer explicitly named to be appealed to in the proofs.
However, Lean's type checker has enough information to fill them in automatically behind the scenes, because no other values would allow the types to match:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10435">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Impl.appendR" data-verso-hover="1830">appendR</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13503" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13509" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13503" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13518" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13503" data-verso-hover="369">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13509" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13518" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">.nil</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13531" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13531" data-verso-hover="1584">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13688" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13689" data-verso-hover="1580">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13531" data-verso-hover="1584">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">▸</span><span class="inter-text"> </span><span class="const token" data-binding="const-Vect.cons" data-verso-hover="1569">.cons</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13688" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Impl.appendR" data-verso-hover="1830">appendR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13689" data-verso-hover="1580">xs</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13531" data-verso-hover="1584">ys</span><span class="unknown token" data-binding="">)</span></code></section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Pros-and-Cons">
                7.5.4. Pros and Cons</h2>
              <p>
                Indexed families have an important property: pattern matching on them affects definitional equality.
For example, in the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect.nil" data-verso-hover="1568">nil</span></code> case in a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> expression on a <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">Vect</span></code>, the length simply <em>becomes</em> <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span></code>.
Definitional equality can be very convenient, because it is always active and does not need to be invoked explicitly.</p>
              <p>
                However, the use of definitional equality with dependent types and pattern matching has serious software engineering drawbacks.
First off, functions must be written especially to be used in types, and functions that are convenient to use in types may not use the most efficient algorithms.
Once a function has been exposed through using it in a type, its implementation has become part of the interface, leading to difficulties in future refactoring.
Secondly, definitional equality can be slow.
When asked to check whether two expressions are definitionally equal, Lean may need to run large amounts of code if the functions in question are complicated and have many layers of abstraction.
Third, error messages that result from failures of definitional equality are not always very easy to understand, because they may be phrased in terms of the internals of functions.
It is not always easy to understand the provenance of the expressions in the error messages.
Finally, encoding non-trivial invariants in a collection of indexed families and dependently-typed functions can often be brittle.
It is often necessary to change early definitions in a system when the exposed reduction behavior of functions proves to not provide convenient definitional equalities.
The alternative is to litter the program with appeals to equality proofs, but these can become quite unwieldy.</p>
              <p>
                In idiomatic Lean code, indexed datatypes are not used very often.
Instead, subtypes and explicit propositions are typically used to enforce important invariants.
This approach involves many explicit proofs, and very few appeals to definitional equality.
As befits an interactive theorem prover, Lean has been designed to make explicit proofs convenient.
Generally speaking, this approach should be preferred in most cases.</p>
              <p>
                However, understanding indexed families of datatypes is important.
Recursive functions such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plusR_zero_left" data-verso-hover="1825">plusR_zero_left</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span></code> are in fact <em>proofs by mathematical induction</em>.
The base case of the recursion corresponds to the base case in induction, and the recursive call represents an appeal to the induction hypothesis.
More generally, new propositions in Lean are often defined as inductive types of evidence, and these inductive types usually have indices.
The process of proving theorems is in fact constructing expressions with these types behind the scenes, in a process not unlike the proofs in this section.
Also, indexed datatypes are sometimes exactly the right tool for the job.
Fluency in their use is an important part of knowing when to use them.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Programming-with-Dependent-Types--Pitfalls-of-Programming-with-Dependent-Types--Exercises">
                7.5.5. Exercises</h2>
              <ul>
                <li>
                  <p>
                    Using a recursive function in the style of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plusR_succ_left" data-verso-hover="1829">plusR_succ_left</span></code>, prove that for all <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>s <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15311" data-verso-hover="5">n</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15313" data-verso-hover="5">k</span></code>, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.15311" data-verso-hover="5">n</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15313" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15311" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.15313" data-verso-hover="5">k</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Write a function on <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Vect" data-verso-hover="1567">Vect</span></code> for which <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusR" data-verso-hover="1819">plusR</span></code> is more natural than <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code>, where <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.plusL" data-verso-hover="1818">plusL</span></code> would require proofs to be used in the definition.
</p>
                  </li>
                </ul>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Programming-with-Dependent-Types/Indices___-Parameters___-and-Universe-Levels/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Indices___-Parameters___-and-Universe-Levels" rel="prev" title="7.4. Indices, Parameters, and Universe Levels"><span class="arrow">←</span><span class="where">7.4. Indices, Parameters, and Universe Levels</span></a><a class="local-button active" href="Programming-with-Dependent-Types/Summary/#Functional-Programming-in-Lean--Programming-with-Dependent-Types--Summary" rel="next" title="7.6. Summary"><span class="where">7.6. Summary</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

