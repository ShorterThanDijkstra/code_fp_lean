<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Datatypes and Patterns</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="current numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-getting-to-know" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-getting-to-know" checked="checked"></label><span class="number">1.</span> <span class=""><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></span></div>
              <table><tr class="numbered"><td class="num">1.1.</td><td><a href="Getting-to-Know-Lean/Evaluating-Expressions/#evaluating">Evaluating Expressions</a></td></tr><tr class="numbered"><td class="num">1.2.</td><td><a href="Getting-to-Know-Lean/Types/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Types">Types</a></td></tr><tr class="numbered"><td class="num">1.3.</td><td><a href="Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions">Functions and Definitions</a></td></tr><tr class="numbered"><td class="num">1.4.</td><td><a href="Getting-to-Know-Lean/Structures/#structures">Structures</a></td></tr><tr class="current numbered"><td class="num">1.5.</td><td><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns">Datatypes and Patterns</a></td></tr><tr class="numbered"><td class="num">1.6.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">Polymorphism</a></td></tr><tr class="numbered"><td class="num">1.7.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences">Additional Conveniences</a></td></tr><tr class="numbered"><td class="num">1.8.</td><td><a href="Getting-to-Know-Lean/Summary/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-datatypes-and-patterns" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-datatypes-and-patterns" checked="checked"></label><span class="number">1.5.</span> <span class="current"><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns">Datatypes and Patterns</a></span></div>
              <table><tr class="numbered"><td class="num">1.5.1.</td><td><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Datatypes-and-Patterns--Pattern-Matching">Pattern Matching</a></td></tr><tr class="numbered"><td class="num">1.5.2.</td><td><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#recursive-functions">Recursive Functions</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Structures/#structures" rel="prev" title="1.4. Structures"><span class="arrow">←</span><span class="where">1.4. Structures</span></a><a class="local-button active" href="Getting-to-Know-Lean/Polymorphism/#polymorphism" rel="next" title="1.6. Polymorphism"><span class="where">1.6. Polymorphism</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              1.5. Datatypes and Patterns<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=datatypes-and-patterns" title="Permalink">🔗</a></span></h1>
            <p>
              Structures enable multiple independent pieces of data to be combined into a coherent whole that is represented by a brand new type.
Types such as structures that group together a collection of values are called <em>product types</em>.
Many domain concepts, however, can't be naturally represented as structures.
For instance, an application might need to track user permissions, where some users are document owners, some may edit documents, and others may only read them.
A calculator has a number of binary operators, such as addition, subtraction, and multiplication.
Structures do not provide an easy way to encode multiple choices.</p>
            <p>
              Similarly, while a structure is an excellent way to keep track of a fixed set of fields, many applications require data that may contain an arbitrary number of elements.
Most classic data structures, such as trees and lists, have a recursive structure, where the tail of a list is itself a list, or where the left and right branches of a binary tree are themselves binary trees.
In the aforementioned calculator, the structure of expressions themselves is recursive.
The summands in an addition expression may themselves be multiplication expressions, for instance.</p>
            <p>
              Datatypes that allow choices are called <em>sum types</em> and datatypes that can include instances of themselves are called <em>recursive datatypes</em>.
Recursive sum types are called <em>inductive datatypes</em>, because mathematical induction may be used to prove statements about them.
When programming, inductive datatypes are consumed through pattern matching and recursive functions.</p>
            <div class="paragraph">
              <p>
                Many of the built-in types are actually inductive datatypes in the standard library.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span></code> is an inductive datatype:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-12383" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12398">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Bool.false" data-verso-hover="19">false</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Bool.true" data-verso-hover="97">true</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span></code><p>
                This definition has two main parts.
The first line provides the name of the new type (<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span></code>), while the remaining lines each describe a constructor.
As with constructors of structures, constructors of inductive datatypes are mere inert receivers of and containers for other data, rather than places to insert arbitrary initialization and validation code.
Unlike structures, inductive datatypes may have multiple constructors.
Here, there are two constructors, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.true" data-verso-hover="97">true</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.false" data-verso-hover="19">false</span></code>, and neither takes any arguments.
Just as a structure declaration places its names in a namespace named after the declared type, an inductive datatype places the names of its constructors in a namespace.
In the Lean standard library, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.true" data-verso-hover="97">true</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.false" data-verso-hover="19">false</span></code> are re-exported from this namespace so that they can be written alone, rather than as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.true" data-verso-hover="97">Bool.true</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool.false" data-verso-hover="19">Bool.false</span></code>, respectively.</p>
              </div>
            <div class="paragraph">
              <p>
                From a data modeling perspective, inductive datatypes are used in many of the same contexts where a sealed abstract class might be used in other languages.
In languages like C# or Java, one might write a similar definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span></code>:</p>
              <pre>abstract class Bool {}
class True : Bool {}
class False : Bool {}
</pre><p>
                However, the specifics of these representations are fairly different. In particular, each non-abstract class creates both a new type and new ways of allocating data. In the object-oriented example, <code>True</code> and <code>False</code> are both types that are more specific than <code>Bool</code>, while the Lean definition introduces only the new type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span></code>.</p>
              </div>
            <p>
              The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> of non-negative integers is an inductive datatype:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-12801" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12815">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11062" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code><p>
              Here, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">zero</span></code> represents 0, while <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> represents the successor of some other number.
The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> mentioned in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code>'s declaration is the very type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> that is in the process of being defined.
<em>Successor</em> means “one greater than”, so the successor of five is six and the successor of 32,185 is 32,186.
Using this definition, <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">4</span></code> is represented as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code>.
This definition is almost like the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span></code> with slightly different names.
The only real difference is that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> is followed by <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11062" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span></code>, which specifies that the constructor <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> takes an argument of type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> which happens to be named <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11062" data-verso-hover="5">n</span></code>.
The names <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">zero</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> are in a namespace named after their type, so they must be referred to as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">Nat.zero</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">Nat.succ</span></code>, respectively.</p>
            <p>
              Argument names, such as <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11062" data-verso-hover="5">n</span></code>, may occur in Lean's error messages and in feedback provided when writing mathematical proofs.
Lean also has an optional syntax for providing arguments by name.
Generally, however, the choice of argument name is less important than the choice of a structure field name, as it does not form as large a part of the API.</p>
            <p>
              In C# or Java, <code>Nat</code> could be defined as follows:</p>
            <pre>abstract class Nat {}
class Zero : Nat {}
class Succ : Nat {
    public Nat n;
    public Succ(Nat pred) {
        n = pred;
    }
}
</pre><p>
              Just as in the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Bool" data-verso-hover="40">Bool</span></code> example above, this defines more types than the Lean equivalent.
Additionally, this example highlights how Lean datatype constructors are much more like subclasses of an abstract class than they are like constructors in C# or Java, as the constructor shown here contains initialization code to be executed.</p>
            <p>
              Sum types are also similar to using a string tag to encode discriminated unions in TypeScript.
In TypeScript, <code>Nat</code> could be defined as follows:</p>
            <pre>interface Zero {
    tag: "zero";
}

interface Succ {
    tag: "succ";
    predecessor: Nat;
}

type Nat = Zero | Succ;
</pre><p>
              Just like C# and Java, this encoding ends up with more types than in Lean, because <code>Zero</code> and <code>Succ</code> are each a type on their own.
It also illustrates that Lean constructors correspond to objects in JavaScript or TypeScript that include a tag that identifies the contents.</p>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Datatypes-and-Patterns--Pattern-Matching">
                1.5.1. Pattern Matching</h2>
              <p>
                In many languages, these kinds of data are consumed by first using an instance-of operator to check which subclass has been received and then reading the values of the fields that are available in the given subclass.
The instance-of check determines which code to run, ensuring that the data needed by this code is available, while the fields themselves provide the data.
In Lean, both of these purposes are simultaneously served by <em>pattern matching</em>.</p>
              <p>
                An example of a function that uses pattern matching is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span></code>, which is a function that returns <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span></code> when its argument is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code>, or false otherwise.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-13925">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.11916" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13958" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11916" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-13958" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.11933" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code><p>
                The <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> expression is provided the function's argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11916" data-verso-hover="5">n</span></code> for destructuring.
If <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11916" data-verso-hover="5">n</span></code> was constructed by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code>, then the first branch of the pattern match is taken, and the result is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span></code>.
If <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11916" data-verso-hover="5">n</span></code> was constructed by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code>, then the second branch is taken, and the result is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code>.</p>
              <div class="paragraph">
                <p>
                  Step-by-step, evaluation of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code> proceeds as follows:</p>
                <div class="eval-steps">
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14129" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14129" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12082" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span></code></div>
                </div>
              <div class="paragraph">
                <p>
                  Evaluation of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code> proceeds similarly:</p>
                <div class="eval-steps">
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14509" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14509" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12379" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code></div>
                </div>
              <p>
                The <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.11933" data-verso-hover="5">k</span></code> in the second branch of the pattern in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-isZero" data-verso-hover="99">isZero</span></code> is not decorative.
It makes the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> that is the argument to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code> visible, with the provided name.
That smaller number can then be used to compute the final result of the expression.</p>
              <div class="paragraph">
                <p>
                  Just as the successor of some number <code class="math inline">n</code> is one greater than <code class="math inline">n</code> (that is, <code class="math inline">n + 1</code>), the predecessor of a number is one less than it.
If <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span></code> is a function that finds the predecessor of a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, then it should be the case that the following examples find the expected result:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">4</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15043" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code><div class="information">
                  <pre>4</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">838</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15354" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">839</span></code><div class="information">
                  <pre>838</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> cannot represent negative numbers, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">Nat.zero</span></code> is a bit of a conundrum.
Usually, when working with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code>, operators that would ordinarily produce a negative number are redefined to produce <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.zero" data-verso-hover="26">zero</span></code> itself:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">0</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-15443" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span></code><div class="information">
                  <pre>0</pre></div>
                </div>
              <p>
                To find the predecessor of a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>, the first step is to check which constructor was used to create it.
If it was <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code>, then the result is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code>.
If it was <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code>, then the name <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.12595" data-verso-hover="5">k</span></code> is used to refer to the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> underneath it.
And this <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> is the desired predecessor, so the result of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code> branch is <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.12595" data-verso-hover="5">k</span></code>.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-14828">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.12578" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14858" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12578" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-14858" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12595" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12595" data-verso-hover="5">k</span></code><div class="paragraph">
                <p>
                  Applying this function to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">5</span></code> yields the following steps:</p>
                <div class="eval-steps">
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">4</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15182" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">4</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15182" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12860" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.12860" data-verso-hover="5">k</span></code><code class="hl lean block" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">4</span></code></div>
                </div>
              <div class="paragraph">
                <p>
                  Pattern matching can be used with structures as well as with sum types.
For instance, a function that extracts the third dimension from a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point3D" data-verso-hover="73">Point3D</span></code> can be written as follows:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15499">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-depth" data-verso-hover="102">depth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13134" data-verso-hover="103">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D" data-verso-hover="73">Point3D</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15536" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13134" data-verso-hover="103">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15536" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D.x" data-verso-hover="66">x</span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13154" data-verso-hover="60">h</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13155" data-verso-hover="60">w</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D.z" data-verso-hover="66">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13156" data-verso-hover="60">d</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13156" data-verso-hover="60">d</span></code><p>
                  In this case, it would have been much simpler to just use the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point3D.z" data-verso-hover="74">Point3D.z</span></code> accessor, but structure patterns are occasionally the simplest way to write a function.</p>
                </div>
              </section>
            <section>
              <h2 id="recursive-functions">
                1.5.2. Recursive Functions<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=recursive-functions" title="Permalink">🔗</a></span></h2>
              <p>
                Definitions that refer to the name being defined are called <em>recursive definitions</em>.
Inductive datatypes are allowed to be recursive; indeed, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code> is an example of such a datatype because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat.succ" data-verso-hover="98">succ</span></code> demands another <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Inductive.Nat" data-verso-hover="6">Nat</span></code>.
Recursive datatypes can represent arbitrarily large data, limited only by technical factors like available memory.
Just as it would be impossible to write down one constructor for each natural number in the datatype definition, it is also impossible to write down a pattern match case for each possibility.</p>
              <div class="paragraph">
                <p>
                  Recursive datatypes are nicely complemented by recursive functions.
A simple recursive function over <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> checks whether its argument is even.
In this case, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code> is even.
Non-recursive branches of the code like this one are called <em>base cases</em>.
The successor of an odd number is even, and the successor of an even number is odd.
This means that a number built with <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code> is even if and only if its argument is not even.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15648">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-even" data-verso-hover="104">even</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13222" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15679" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13222" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15679" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13239" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.not" data-verso-hover="105">not</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-even" data-verso-hover="104">even</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13239" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code></div>
              <p>
                This pattern of thought is typical for writing recursive functions on <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.
First, identify what to do for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span></code>.
Then, determine how to transform a result for an arbitrary <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> into a result for its successor, and apply this transformation to the result of the recursive call.
This pattern is called <em>structural recursion</em>.</p>
              <div class="paragraph">
                <p>
                  Unlike many languages, Lean ensures by default that every recursive function will eventually reach a base case.
From a programming perspective, this rules out accidental infinite loops.
But this feature is especially important when proving theorems, where infinite loops cause major difficulties.
A consequence of this is that Lean will not accept a version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-even" data-verso-hover="104">even</span></code> that attempts to invoke itself recursively on the original number:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16331">def</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">fail to show termination for
  evenLoops
with errors
failed to infer structural recursion:
Not considering parameter n of evenLoops:
  it is unchanged in the recursive calls
no parameters suitable for structural recursion

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments</code></span></span><span class="const token" data-binding="const-evenLoops" data-verso-hover="106">evenLoops</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13458" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16367" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13458" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16367" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13475" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.not" data-verso-hover="105">not</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-evenLoops" data-verso-hover="106">evenLoops</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13458" data-verso-hover="5">n</span><span class="unknown token" data-binding="">)</span></code><p>
                  The important part of the error message is that Lean could not determine that the recursive function always reaches a base case (because it doesn't).</p>
                <div class="error">
                  <pre>fail to show termination for
  evenLoops
with errors
failed to infer structural recursion:
Not considering parameter n of evenLoops:
  it is unchanged in the recursive calls
no parameters suitable for structural recursion

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Even though addition takes two arguments, only one of them needs to be inspected.
To add zero to a number <code class="math inline">n</code>, just return <code class="math inline">n</code>.
To add the successor of <code class="math inline">k</code> to <code class="math inline">n</code>, take the successor of the result of adding <code class="math inline">k</code> to <code class="math inline">n</code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-16505">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13543" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13545" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16545" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13545" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16545" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13543" data-verso-hover="5">n</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13563" data-verso-hover="5">k'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13543" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13563" data-verso-hover="5">k'</span><span class="unknown token" data-binding="">)</span></code></div>
              <div class="paragraph">
                <p>
                  In the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span></code>, the name <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.13563" data-verso-hover="5">k'</span></code> is chosen to indicate that it is connected to, but not identical with, the argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.13545" data-verso-hover="5">k</span></code>.
For instance, walking through the evaluation of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span></code> yields the following steps:</p>
                <div class="eval-steps">
                  <code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16813" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16813" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13851" data-verso-hover="5">k'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13851" data-verso-hover="5">k'</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16965" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-16965" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14037" data-verso-hover="5">k'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14037" data-verso-hover="5">k'</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-17117" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-17117" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text">
</span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14211" data-verso-hover="5">k'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14211" data-verso-hover="5">k'</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">5</span></code></div>
                </div>
              <div class="paragraph">
                <p>
                  One way to think about addition is that <code class="math inline">n + k</code> applies <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code> <code class="math inline">k</code> times to <code class="math inline">n</code>.
Similarly, multiplication <code class="math inline">n × k</code> adds <code class="math inline">n</code> to itself <code class="math inline">k</code> times and subtraction <code class="math inline">n - k</code> takes <code class="math inline">n</code>'s predecessor <code class="math inline">k</code> times.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17294">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-times" data-verso-hover="108">times</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14563" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14565" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-17335" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14565" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-17335" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14583" data-verso-hover="5">k'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-plus" data-verso-hover="107">plus</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14563" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-times" data-verso-hover="108">times</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14563" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14583" data-verso-hover="5">k'</span><span class="unknown token" data-binding="">)</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-17468">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-minus" data-verso-hover="109">minus</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14763" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14765" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-17509" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14765" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-17509" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14763" data-verso-hover="5">n</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14783" data-verso-hover="5">k'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-pred" data-verso-hover="101">pred</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-minus" data-verso-hover="109">minus</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14763" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14783" data-verso-hover="5">k'</span><span class="unknown token" data-binding="">)</span></code></div>
              <div class="paragraph">
                <p>
                  Not every function can be easily written using structural recursion.
The understanding of addition as iterated <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code>, multiplication as iterated addition, and subtraction as iterated predecessor suggests an implementation of division as iterated subtraction.
In this case, if the numerator is less than the divisor, the result is zero.
Otherwise, the result is the successor of dividing the numerator minus the divisor by the divisor.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-18198">def</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">fail to show termination for
  div
with errors
failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    div (n - k) k
Cannot use parameter k:
  failed to eliminate recursive application
    div (n - k) k


Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
              n k
1) 1014:17-30 ≤ =
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="const token" data-binding="const-div" data-verso-hover="110">div</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14904" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-18237" data-verso-hover="16">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14904" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">&lt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-18237" data-verso-hover="16">then</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-termIfThenElse-18237" data-verso-hover="16">else</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-div" data-verso-hover="110">div</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.14904" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.14906" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code></div>
              <div class="paragraph">
                <p>
                  As long as the second argument is not <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">0</span></code>, this program terminates, as it always makes progress towards the base case.
However, it is not structurally recursive, because it doesn't follow the pattern of finding a result for zero and transforming a result for a smaller <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> into a result for its successor.
In particular, the recursive invocation of the function is applied to the result of another function call, rather than to an input constructor's argument.
Thus, Lean rejects it with the following message:</p>
                <div class="error">
                  <pre>fail to show termination for
  div
with errors
failed to infer structural recursion:
Cannot use parameter n:
  failed to eliminate recursive application
    div (n - k) k
Cannot use parameter k:
  failed to eliminate recursive application
    div (n - k) k


Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
              n k
1) 1014:17-30 ≤ =
Please use `termination_by` to specify a decreasing measure.</pre></div>
                <p>
                  This message means that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-div" data-verso-hover="110">div</span></code> requires a manual proof of termination.
This topic is explored in <a href="Programming___-Proving___-and-Performance/More-Inequalities/#division-as-iterated-subtraction">the final chapter</a>.</p>
                </div>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Structures/#structures" rel="prev" title="1.4. Structures"><span class="arrow">←</span><span class="where">1.4. Structures</span></a><a class="local-button active" href="Getting-to-Know-Lean/Polymorphism/#polymorphism" rel="next" title="1.6. Polymorphism"><span class="where">1.6. Polymorphism</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

