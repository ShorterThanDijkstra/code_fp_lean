<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Running a Program</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "‚èé";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="current numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-hello-world" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-hello-world" checked="checked"></label><span class="number">2.</span>¬†<span class=""><a href="Hello___-World___/#hello-world">Hello, World!</a></span></div>
              <table><tr class="current numbered"><td class="num">2.1.</td><td><a href="Hello___-World___/Running-a-Program/#running-a-program">Running a Program</a></td></tr><tr class="numbered"><td class="num">2.2.</td><td><a href="Hello___-World___/Step-By-Step/#Functional-Programming-in-Lean--Hello___-World___--Step-By-Step">Step By Step</a></td></tr><tr class="numbered"><td class="num">2.3.</td><td><a href="Hello___-World___/Starting-a-Project/#Functional-Programming-in-Lean--Hello___-World___--Starting-a-Project">Starting a Project</a></td></tr><tr class="numbered"><td class="num">2.4.</td><td><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat">Worked Example: <code>cat</code></a></td></tr><tr class="numbered"><td class="num">2.5.</td><td><a href="Hello___-World___/Additional-Conveniences/#Functional-Programming-in-Lean--Hello___-World___--Additional-Conveniences">Additional Conveniences</a></td></tr><tr class="numbered"><td class="num">2.6.</td><td><a href="Hello___-World___/Summary/#Functional-Programming-in-Lean--Hello___-World___--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-running-a-program" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-running-a-program" checked="checked"></label><span class="number">2.1.</span>¬†<span class="current"><a href="Hello___-World___/Running-a-Program/#running-a-program">Running a Program</a></span></div>
              <table><tr class="numbered"><td class="num">2.1.1.</td><td><a href="Hello___-World___/Running-a-Program/#Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Anatomy-of-a-Greeting">Anatomy of a Greeting</a></td></tr><tr class="numbered"><td class="num">2.1.2.</td><td><a href="Hello___-World___/Running-a-Program/#Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Functional-Programming-vs-Effects">Functional Programming vs Effects</a></td></tr><tr class="numbered"><td class="num">2.1.3.</td><td><a href="Hello___-World___/Running-a-Program/#Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Real-World-Functional-Programming">Real-World Functional Programming</a></td></tr><tr class="numbered"><td class="num">2.1.4.</td><td><a href="Hello___-World___/Running-a-Program/#Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Combining--IO--Actions">Combining <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> Actions</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Hello___-World___/#hello-world" rel="prev" title="2. Hello, World!"><span class="arrow">‚Üê</span><span class="where">2. Hello, World!</span></a><a class="local-button active" href="Hello___-World___/Step-By-Step/#Functional-Programming-in-Lean--Hello___-World___--Step-By-Step" rel="next" title="2.2. Step By Step"><span class="where">2.2. Step By Step</span><span class="arrow">‚Üí</span></a></nav>
          <section>
            <h1>
              2.1.¬†Running a Program<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=running-a-program" title="Permalink">üîó</a></span></h1>
            <div class="paragraph">
              <p>
                The simplest way to run a Lean program is to use the <code>--run</code> option to the Lean executable.
Create a file called <code>Hello.lean</code> and enter the following contents:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-0">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-main" data-verso-hover="249">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.println" data-verso-hover="250">IO.println</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="8">"Hello, world!"</span><span class="inter-text">
</span><span class="unknown token" data-binding=""></span></code></div>
            <div class="paragraph">
              <p>
                Then, from the command line, run:</p>
              <div class="shell-command block">
                <code class="command"><code class="prompt">$ </code>lean --run Hello.lean</code></div>
              <p>
                The program displays <code>Hello, world!</code> and exits.</p>
              </div>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Anatomy-of-a-Greeting">
                2.1.1.¬†Anatomy of a Greeting</h2>
              <p>
                When Lean is invoked with the <code>--run</code> option, it invokes the program's <code>main</code> definition.
In programs that do not take command-line arguments, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="249">main</span></code> should have type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.
This means that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="249">main</span></code> is not a function, because there are no arrows (<code>‚Üí</code>) in its type.
Instead of being a function that has side effects, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="249">main</span></code> consists of a description of effects to be carried out.</p>
              <p>
                As discussed in <a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">the preceding chapter</a>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> is the simplest inductive type.
It has a single constructor called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit.unit" data-verso-hover="186">unit</span></code> that takes no arguments.
Languages in the C tradition have a notion of a <code>void</code> function that does not return any value at all.
In Lean, all functions take an argument and return a value, and the lack of interesting arguments or return values can be signaled by using the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> type instead.
If <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span></code> represents a single bit of information, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> represents zero bits of information.</p>
              <p>
                <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.741" data-verso-hover="113">Œ±</span></code> is the type of a program that, when executed, will either throw an exception or return a value of type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.741" data-verso-hover="113">Œ±</span></code>.
During execution, this program may have side effects.
These programs are referred to as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> <em>actions</em>.
Lean distinguishes between <em>evaluation</em> of expressions, which strictly adheres to the mathematical model of substitution of values for variables and reduction of sub-expressions without side effects, and <em>execution</em> of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions, which rely on an external system to interact with the world.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.println" data-verso-hover="250">IO.println</span></code> is a function from strings to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions that, when executed, write the given string to standard output.
Because this action doesn't read any interesting information from the environment in the process of emitting the string, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.println" data-verso-hover="250">IO.println</span></code> has type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üí</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.
If it did return something interesting, then that would be indicated by the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> action having a type other than <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Functional-Programming-vs-Effects">
                2.1.2.¬†Functional Programming vs Effects</h2>
              <p>
                Lean's model of computation is based on the evaluation of mathematical expressions, in which variables are given exactly one value that does not change over time.
The result of evaluating an expression does not change, and evaluating the same expression again will always yield the same result.</p>
              <p>
                On the other hand, useful programs must interact with the world.
A program that performs neither input nor output can't ask a user for data, create files on disk, or open network connections.
Lean is written in itself, and the Lean compiler certainly reads files, creates files, and interacts with text editors.
How can a language in which the same expression always yields the same result support programs that read files from disk, when the contents of these files might change over time?</p>
              <p>
                This apparent contradiction can be resolved by thinking a bit differently about side effects.
Imagine a caf√© that sells coffee and sandwiches.
This caf√© has two employees: a cook who fulfills orders, and a worker at the counter who interacts with customers and places order slips.
The cook is a surly person, who really prefers not to have any contact with the world outside, but who is very good at consistently delivering the food and drinks that the caf√© is known for.
In order to do this, however, the cook needs peace and quiet, and can't be disturbed with conversation.
The counter worker is friendly, but completely incompetent in the kitchen.
Customers interact with the counter worker, who delegates all actual cooking to the cook.
If the cook has a question for a customer, such as clarifying an allergy, they send a little note to the counter worker, who interacts with the customer and passes a note back to the cook with the result.</p>
              <p>
                In this analogy, the cook is the Lean language.
When provided with an order, the cook faithfully and consistently delivers what is requested.
The counter worker is the surrounding run-time system that interacts with the world and can accept payments, dispense food, and have conversations with customers.
Working together, the two employees serve all the functions of the restaurant, but their responsibilities are divided, with each performing the tasks that they're best at.
Just as keeping customers away allows the cook to focus on making truly excellent coffee and sandwiches, Lean's lack of side effects allows programs to be used as part of formal mathematical proofs.
It also helps programmers understand the parts of the program in isolation from each other, because there are no hidden state changes that create subtle coupling between components.
The cook's notes represent <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions that are produced by evaluating Lean expressions, and the counter worker's replies are the values that are passed back from effects.</p>
              <p>
                This model of side effects is quite similar to how the overall aggregate of the Lean language, its compiler, and its run-time system (RTS) work.
Primitives in the run-time system, written in C, implement all the basic effects.
When running a program, the RTS invokes the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="249">main</span></code> action, which returns new <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions to the RTS for execution.
The RTS executes these actions, delegating to the user's Lean code to carry out computations.
From the internal perspective of Lean, programs are free of side effects, and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions are just descriptions of tasks to be carried out.
From the external perspective of the program's user, there is a layer of side effects that create an interface to the program's core logic.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Real-World-Functional-Programming">
                2.1.3.¬†Real-World Functional Programming</h2>
              <p>
                The other useful way to think about side effects in Lean is by considering <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions to be functions that take the entire world as an argument and return a value paired with a new world.
In this case, reading a line of text from standard input <em>is</em> a pure function, because a different world is provided as an argument each time.
Writing a line of text to standard output is a pure function, because the world that the function returns is different from the one that it began with.
Programs do need to be careful to never re-use the world, nor to fail to return a new world‚Äîthis would amount to time travel or the end of the world, after all.
Careful abstraction boundaries can make this style of programming safe.
If every primitive <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> action accepts one world and returns a new one, and they can only be combined with tools that preserve this invariant, then the problem cannot occur.</p>
              <p>
                This model cannot be implemented.
After all, the entire universe cannot be turned into a Lean value and placed into memory.
However, it is possible to implement a variation of this model with an abstract token that stands for the world.
When the program is started, it is provided with a world token.
This token is then passed on to the IO primitives, and their returned tokens are similarly passed to the next step.
At the end of the program, the token is returned to the operating system.</p>
              <p>
                This model of side effects is a good description of how <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions as descriptions of tasks to be carried out by the RTS are represented internally in Lean.
The actual functions that transform the real world are behind an abstraction barrier.
But real programs typically consist of a sequence of effects, rather than just one.
To enable programs to use multiple effects, there is a sub-language of Lean called <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> notation that allows these primitive <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions to be safely composed into a larger, useful program.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Running-a-Program--Combining--IO--Actions">
                2.1.4.¬†Combining <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> Actions</h2>
              <p>
                Most useful programs accept input in addition to producing output.
Furthermore, they may take decisions based on input, using the input data as part of a computation.
The following program, called <code>HelloName.lean</code>, asks the user for their name and then greets them:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-30">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-main" data-verso-hover="249">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üê</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="252">IO.getStdin</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-123">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üê</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStdout" data-verso-hover="253">IO.getStdout</span><span class="inter-text">
</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.putStrLn" data-verso-hover="254">putStrLn</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="255">"How would you like to be addressed?"</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-255">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.256" data-verso-hover="39">input</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üê</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.getLine" data-verso-hover="256">getLine</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-285">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="39">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.256" data-verso-hover="39">input</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-String.dropRightWhile" data-verso-hover="257">dropRightWhile</span><span class="inter-text"> </span><span class="const token" data-binding="const-Char.isWhitespace" data-verso-hover="258">Char.isWhitespace</span><span class="inter-text">
</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.putStrLn" data-verso-hover="254">putStrLn</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termS!_-401">s!</span><span class="unknown token" data-binding="">"Hello, {</span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="39">name</span><span class="unknown token" data-binding="">}!"</span></code><p>
                In this program, the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="249">main</span></code> action consists of a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> block.
This block contains a sequence of <em>statements</em>, which can be both local variables (introduced using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code>) and actions that are to be executed.
Just as SQL can be thought of as a special-purpose language for interacting with databases, the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> syntax can be thought of as a special-purpose sub-language within Lean that is dedicated to modeling imperative programs.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions that are built with a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> block are executed by executing the statements in order.</p>
              <p>
                This program can be run in the same manner as the prior program:</p>
              <div class="shell-command block">
                <code class="command"><code class="prompt">$ </code>lean --run HelloName.lean</code></div>
              <p>
                If the user responds with <code>David</code>, a session of interaction with the program reads:</p>
              <pre>How would you like to be addressed?
David
Hello, David!
</pre><p>
                The type signature line is just like the one for <code>Hello.lean</code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-30">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-main" data-verso-hover="249">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code><p>
                The only difference is that it ends with the keyword <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code>, which initiates a sequence of commands.
Each indented line following the keyword <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> is part of the same sequence of commands.</p>
              <p>
                The first two lines, which read:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üê</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="252">IO.getStdin</span><span class="inter-text">
</span><span class="inter-text"></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-123">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üê</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStdout" data-verso-hover="253">IO.getStdout</span></code><p>
                retrieve the <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span></code> handles by executing the library actions <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="252">IO.getStdin</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.getStdout" data-verso-hover="253">IO.getStdout</span></code>, respectively.
In a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code> block, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span></code> has a slightly different meaning than in an ordinary expression.
Ordinarily, the local definition in a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span></code> can be used in just one expression, which immediately follows the local definition.
In a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code> block, local bindings introduced by <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span></code> are available in all statements in the remainder of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code> block, rather than just the next one.
Additionally, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span></code> typically connects the name being defined to its definition using <code>:=</code>, while some <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-95">let</span></code> bindings in <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code> use a left arrow (<code>‚Üê</code> or <code>&lt;-</code>) instead.
Using an arrow means that the value of the expression is an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> action that should be executed, with the result of the action saved in the local variable.
In other words, if the expression to the right of the arrow has type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.741" data-verso-hover="113">Œ±</span></code>, then the variable has type <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.741" data-verso-hover="113">Œ±</span></code> in the remainder of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code> block.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="252">IO.getStdin</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.getStdout" data-verso-hover="253">IO.getStdout</span></code> are <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions in order to allow <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span></code> to be locally overridden in a program, which can be convenient.
If they were global variables as in C, then there would be no meaningful way to override them, but <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions can return different values each time they are executed.</p>
              <p>
                The next part of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-52">do</span></code> block is responsible for asking the user for their name:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.putStrLn" data-verso-hover="254">putStrLn</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="255">"How would you like to be addressed?"</span><span class="inter-text">
</span><span class="inter-text"></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-255">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.256" data-verso-hover="39">input</span><span class="inter-text"> </span><span class="unknown token" data-binding="">‚Üê</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.getLine" data-verso-hover="256">getLine</span><span class="inter-text">
</span><span class="inter-text"></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-285">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="39">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.256" data-verso-hover="39">input</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-String.dropRightWhile" data-verso-hover="257">dropRightWhile</span><span class="inter-text"> </span><span class="const token" data-binding="const-Char.isWhitespace" data-verso-hover="258">Char.isWhitespace</span></code><p>
                The first line writes the question to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span></code>, the second line requests input from <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.128" data-verso-hover="251">stdin</span></code>, and the third line removes the trailing newline (plus any other trailing whitespace) from the input line.
The definition of <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.262" data-verso-hover="39">name</span></code> uses <code>:=</code>, rather than <code>‚Üê</code>, because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.dropRightWhile" data-verso-hover="257">String.dropRightWhile</span></code> is an ordinary function on strings, rather than an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> action.</p>
              <p>
                Finally, the last line in the program is:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.putStrLn" data-verso-hover="254">putStrLn</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termS!_-401">s!</span><span class="unknown token" data-binding="">"Hello, {</span><span class="var token" data-binding="var-_uniq.262" data-verso-hover="39">name</span><span class="unknown token" data-binding="">}!"</span></code><p>
                It uses <a href="Getting-to-Know-Lean/Additional-Conveniences/#string-interpolation">string interpolation</a> to insert the provided name into a greeting string, writing the result to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.172" data-verso-hover="251">stdout</span></code>.
</p>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Hello___-World___/#hello-world" rel="prev" title="2. Hello, World!"><span class="arrow">‚Üê</span><span class="where">2. Hello, World!</span></a><a class="local-button active" href="Hello___-World___/Step-By-Step/#Functional-Programming-in-Lean--Hello___-World___--Step-By-Step" rel="next" title="2.2. Step By Step"><span class="where">2.2. Step By Step</span><span class="arrow">‚Üí</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

