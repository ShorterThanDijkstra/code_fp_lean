<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Worked Example:  cat</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="current numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-hello-world" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-hello-world" checked="checked"></label><span class="number">2.</span> <span class=""><a href="Hello___-World___/#hello-world">Hello, World!</a></span></div>
              <table><tr class="numbered"><td class="num">2.1.</td><td><a href="Hello___-World___/Running-a-Program/#running-a-program">Running a Program</a></td></tr><tr class="numbered"><td class="num">2.2.</td><td><a href="Hello___-World___/Step-By-Step/#Functional-Programming-in-Lean--Hello___-World___--Step-By-Step">Step By Step</a></td></tr><tr class="numbered"><td class="num">2.3.</td><td><a href="Hello___-World___/Starting-a-Project/#Functional-Programming-in-Lean--Hello___-World___--Starting-a-Project">Starting a Project</a></td></tr><tr class="current numbered"><td class="num">2.4.</td><td><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat">Worked Example: <code>cat</code></a></td></tr><tr class="numbered"><td class="num">2.5.</td><td><a href="Hello___-World___/Additional-Conveniences/#Functional-Programming-in-Lean--Hello___-World___--Additional-Conveniences">Additional Conveniences</a></td></tr><tr class="numbered"><td class="num">2.6.</td><td><a href="Hello___-World___/Summary/#Functional-Programming-in-Lean--Hello___-World___--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat" checked="checked"></label><span class="number">2.4.</span> <span class="current"><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat">Worked Example: <code>cat</code></a></span></div>
              <table><tr class="numbered"><td class="num">2.4.1.</td><td><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Getting-started">Getting started</a></td></tr><tr class="numbered"><td class="num">2.4.2.</td><td><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Concatenating-Streams">Concatenating Streams</a></td></tr><tr class="numbered"><td class="num">2.4.3.</td><td><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Meow___">Meow!</a></td></tr><tr class="numbered"><td class="num">2.4.4.</td><td><a href="Hello___-World___/Worked-Example___--cat/#Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Exercise">Exercise</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Hello___-World___/Starting-a-Project/#Functional-Programming-in-Lean--Hello___-World___--Starting-a-Project" rel="prev" title="2.3. Starting a Project"><span class="arrow">←</span><span class="where">2.3. Starting a Project</span></a><a class="local-button active" href="Hello___-World___/Additional-Conveniences/#Functional-Programming-in-Lean--Hello___-World___--Additional-Conveniences" rel="next" title="2.5. Additional Conveniences"><span class="where">2.5. Additional Conveniences</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              2.4. Worked Example: <code>cat</code></h1>
            <p>
              The standard Unix utility <code>cat</code> takes a number of command-line options, followed by zero or more input files.
If no files are provided, or if one of them is a dash (<code>-</code>), then it takes the standard input as the corresponding input instead of reading a file.
The contents of the inputs are written, one after the other, to the standard output.
If a specified input file does not exist, this is noted on standard error, but <code>cat</code> continues concatenating the remaining inputs.
A non-zero exit code is returned if any of the input files do not exist.</p>
            <p>
              This section describes a simplified version of <code>cat</code>, called <code>feline</code>.
Unlike commonly-used versions of <code>cat</code>, <code>feline</code> has no command-line options for features such as numbering lines, indicating non-printing characters, or displaying help text.
Furthermore, it cannot read more than once from a standard input that's associated with a terminal device.</p>
            <p>
              To get the most benefit from this section, follow along yourself.
It's OK to copy-paste the code examples, but it's even better to type them in by hand.
This makes it easier to learn the mechanical process of typing in code, recovering from mistakes, and interpreting feedback from the compiler.</p>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Getting-started">
                2.4.1. Getting started</h2>
              <p>
                The first step in implementing <code>feline</code> is to create a package and decide how to organize the code.
In this case, because the program is so simple, all the code will be placed in <code>Main.lean</code>.
The first step is to run <code>lake new feline</code>.
Edit the Lakefile to remove the library, and delete the generated library code and the reference to it from <code>Main.lean</code>.
Once this has been done, <code>lakefile.toml</code> should contain:</p>
              <div class="example-file">
                File: <code>lakefile.toml</code><code class="line">name = "feline"</code><code class="line">version = "0.1.0"</code><code class="line">defaultTargets = ["feline"]</code><code class="line"></code><code class="line">[[lean_exe]]</code><code class="line">name = "feline"</code><code class="line">root = "Main"</code></div>
              <p>
                and <code>Main.lean</code> should contain something like:</p>
              <div class="example-file">
                File: <code>Main.lean</code><code class="line">def main : IO Unit :=</code><code class="line">  IO.println s!"Hello, cats!"</code></div>
              <p>
                Alternatively, running <code>lake new feline exe</code> instructs <code>lake</code> to use a template that does not include a library section, making it unnecessary to edit the file.</p>
              <p>
                Ensure that the code can be built by running <span class="shell-command inline"><code class="command">lake build</code></span>.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Concatenating-Streams">
                2.4.2. Concatenating Streams</h2>
              <p>
                Now that the basic skeleton of the program has been built, it's time to actually enter the code.
A proper implementation of <code>cat</code> can be used with infinite IO streams, such as <code>/dev/random</code>, which means that it can't read its input into memory before outputting it.
Furthermore, it should not work one character at a time, as this leads to frustratingly slow performance.
Instead, it's better to read contiguous blocks of data all at once, directing the data to the standard output one block at a time.</p>
              <p>
                The first step is to decide how big of a block to read.
For the sake of simplicity, this implementation uses a conservative 20 kilobyte block.
<code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-USize" data-verso-hover="285">USize</span></code> is analogous to <code>size_t</code> in C—it's an unsigned integer type that is big enough to represent all valid array sizes.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-19">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-bufsize" data-verso-hover="286">bufsize</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-USize" data-verso-hover="285">USize</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="287">20</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="287">1024</span></code><section>
                <h3 id="streams">
                  2.4.2.1. Streams<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=streams" title="Permalink">🔗</a></span></h3>
                <p>
                  The main work of <code>feline</code> is done by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code>, which reads input one block at a time, dumping the result to standard output, until the end of the input has been reached.
The end of the input is indicated by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.FS.Stream.read" data-verso-hover="289">read</span></code> returning an empty byte array:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-92">partial</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-100">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="251">stream</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.FS.Stream" data-verso-hover="259">IO.FS.Stream</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-146">do</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-151">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.140" data-verso-hover="290">buf</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="251">stream</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.read" data-verso-hover="289">read</span><span class="inter-text"> </span><span class="const token" data-binding="const-bufsize" data-verso-hover="286">bufsize</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-185">if</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.140" data-verso-hover="290">buf</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-ByteArray.isEmpty" data-verso-hover="291">isEmpty</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-185">then</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-Pure.pure" data-verso-hover="270">pure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-null-219">else</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-254">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.387" data-verso-hover="251">stdout</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStdout" data-verso-hover="253">IO.getStdout</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="var token" data-binding="var-_uniq.387" data-verso-hover="251">stdout</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.write" data-verso-hover="292">write</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.140" data-verso-hover="290">buf</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.73" data-verso-hover="251">stream</span></code><p>
                  The <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> function is declared <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-92">partial</span></code>, because it calls itself recursively on input that is not immediately smaller than an argument.
When a function is declared to be partial, Lean does not require a proof that it terminates.
On the other hand, partial functions are also much less amenable to proofs of correctness, because allowing infinite loops in Lean's logic would make it unsound.
However, there is no way to prove that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> terminates, because infinite input (such as from <code>/dev/random</code>) would mean that it does not, in fact, terminate.
In cases like this, there is no alternative to declaring the function <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.partial-92">partial</span></code>.</p>
                <p>
                  The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.FS.Stream" data-verso-hover="259">IO.FS.Stream</span></code> represents a POSIX stream.
Behind the scenes, it is represented as a structure that has one field for each POSIX stream operation.
Each operation is represented as an IO action that provides the corresponding operation:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-57">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Str.Stream" data-verso-hover="293">Stream</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-74">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Str.Stream.flush" data-verso-hover="294">flush</span><span class="inter-text">   </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Str.Stream.read" data-verso-hover="295">read</span><span class="inter-text">    </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-USize" data-verso-hover="285">USize</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-ByteArray" data-verso-hover="296">ByteArray</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Str.Stream.write" data-verso-hover="297">write</span><span class="inter-text">   </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-ByteArray" data-verso-hover="296">ByteArray</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Str.Stream.getLine" data-verso-hover="298">getLine</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Str.Stream.putStr" data-verso-hover="299">putStr</span><span class="inter-text">  </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Str.Stream.isTty" data-verso-hover="300">isTty</span><span class="inter-text">   </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-BaseIO" data-verso-hover="301">BaseIO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span></code><p>
                  The type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BaseIO" data-verso-hover="301">BaseIO</span></code> is a variant of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> that rules out run-time errors.
The Lean compiler contains <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions (such as <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.getStdout" data-verso-hover="253">IO.getStdout</span></code>, which is called in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code>) to get streams that represent standard input, standard output, and standard error.
These are <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions rather than ordinary definitions because Lean allows these standard POSIX streams to be replaced in a process, which makes it easier to do things like capturing the output from a program into a string by writing a custom <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.FS.Stream" data-verso-hover="259">IO.FS.Stream</span></code>.</p>
                <p>
                  The control flow in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> is essentially a <code>while</code> loop.
When <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> is called, if the stream has reached the end of the file, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Pure.pure" data-verso-hover="270">pure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">)</span></code> terminates the function by returning the constructor for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code>.
If the stream has not yet reached the end of the file, one block is read, and its contents are written to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.387" data-verso-hover="251">stdout</span></code>, after which <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> calls itself directly.
The recursive calls continue until <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.73" data-verso-hover="251">stream</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.read" data-verso-hover="289">read</span></code> returns an empty byte array, which indicates the end of the file.</p>
                <p>
                  When an <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if</span></code> expression occurs as a statement in a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code>, as in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code>, each branch of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if</span></code> is implicitly provided with a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code>.
In other words, the sequence of steps following the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">else</span></code> are treated as a sequence of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> actions to be executed, just as if they had a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> at the beginning.
Names introduced with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> in the branches of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if</span></code> are visible only in their own branches, and are not in scope outside of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if</span></code>.</p>
                <p>
                  There is no danger of running out of stack space while calling <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> because the recursive call happens as the very last step in the function, and its result is returned directly rather than being manipulated or computed with.
This kind of recursion is called <em>tail recursion</em>, and it is described in more detail <a href="Programming___-Proving___-and-Performance/Tail-Recursion/#tail-recursion">later in this book</a>.
Because the compiled code does not need to retain any state, the Lean compiler can compile the recursive call to a jump.</p>
                <p>
                  If <code>feline</code> only redirected standard input to standard output, then <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span></code> would be sufficient.
However, it also needs to be able to open files that are provided as command-line arguments and emit their contents.
When its argument is the name of a file that exists, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fileStream" data-verso-hover="302">fileStream</span></code> returns a stream that reads the file's contents.
When the argument is not a file, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fileStream" data-verso-hover="302">fileStream</span></code> emits an error and returns <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span></code>.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-392">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-fileStream" data-verso-hover="302">fileStream</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.463" data-verso-hover="303">filename</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-System.FilePath" data-verso-hover="304">System.FilePath</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.FS.Stream" data-verso-hover="259">IO.FS.Stream</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-466">do</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-499">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.595" data-verso-hover="305">fileExists</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.463" data-verso-hover="303">filename</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-System.FilePath.pathExists" data-verso-hover="306">pathExists</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-540">if</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.not" data-verso-hover="105">not</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.595" data-verso-hover="305">fileExists</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-540">then</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-599">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="251">stderr</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStderr" data-verso-hover="307">IO.getStderr</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="var token" data-binding="var-_uniq.729" data-verso-hover="251">stderr</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-IO.FS.Stream.putStrLn" data-verso-hover="254">putStrLn</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termS!_-647">s!</span><span class="unknown token" data-binding="">"File not found: {</span><span class="var token" data-binding="var-_uniq.463" data-verso-hover="303">filename</span><span class="unknown token" data-binding="">}"</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-Pure.pure" data-verso-hover="270">pure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-null-694">else</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-703">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.947" data-verso-hover="308">handle</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.FS.Handle.mk" data-verso-hover="309">IO.FS.Handle.mk</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.463" data-verso-hover="303">filename</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.FS.Mode.read" data-verso-hover="310">IO.FS.Mode.read</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-Pure.pure" data-verso-hover="270">pure</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-IO.FS.Stream.ofHandle" data-verso-hover="311">IO.FS.Stream.ofHandle</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.947" data-verso-hover="308">handle</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><p>
                  Opening a file as a stream takes two steps.
First, a file handle is created by opening the file in read mode.
A Lean file handle tracks an underlying file descriptor.
When there are no references to the file handle value, a finalizer closes the file descriptor.
Second, the file handle is given the same interface as a POSIX stream using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.FS.Stream.ofHandle" data-verso-hover="311">IO.FS.Stream.ofHandle</span></code>, which fills each field of the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO.FS.Stream" data-verso-hover="259">Stream</span></code> structure with the corresponding <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span></code> action that works on file handles.</p>
                </section>
              <section>
                <h3 id="handling-input">
                  2.4.2.2. Handling Input<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=handling-input" title="Permalink">🔗</a></span></h3>
                <p>
                  The main loop of <code>feline</code> is another tail-recursive function, called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code>.
In order to return a non-zero exit code if any of the inputs could not be read, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> takes an argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.1204" data-verso-hover="313">exitCode</span></code> that represents the current exit code for the whole program.
Additionally, it takes a list of input files to be processed.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1153">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-process" data-verso-hover="312">process</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1204" data-verso-hover="313">exitCode</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-UInt32" data-verso-hover="314">UInt32</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1207" data-verso-hover="315">args</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-UInt32" data-verso-hover="314">UInt32</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-1221">do</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doMatch-1226">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1207" data-verso-hover="315">args</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doMatch-1226">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Pure.pure" data-verso-hover="270">pure</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1204" data-verso-hover="313">exitCode</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="316">"-"</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1327" data-verso-hover="315">args</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-1289">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1432" data-verso-hover="251">stdin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO.getStdin" data-verso-hover="252">IO.getStdin</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1432" data-verso-hover="251">stdin</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-process" data-verso-hover="312">process</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1204" data-verso-hover="313">exitCode</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1327" data-verso-hover="315">args</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1503" data-verso-hover="39">filename</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1504" data-verso-hover="315">args</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-1384">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1546" data-verso-hover="317">stream</span><span class="inter-text"> </span><span class="unknown token" data-binding="">←</span><span class="inter-text"> </span><span class="const token" data-binding="const-fileStream" data-verso-hover="302">fileStream</span><span class="inter-text"> </span><span class="unknown token" data-binding="const-System.FilePath.mk" data-verso-hover="318">⟨</span><span class="var token" data-binding="var-_uniq.1503" data-verso-hover="39">filename</span><span class="unknown token" data-binding="const-System.FilePath.mk" data-verso-hover="318">⟩</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doMatch-1429">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1546" data-verso-hover="317">stream</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doMatch-1429">with</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">      </span><span class="const token" data-binding="const-process" data-verso-hover="312">process</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="313">1</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1504" data-verso-hover="315">args</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1581" data-verso-hover="251">stream</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">      </span><span class="const token" data-binding="const-dump" data-verso-hover="288">dump</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1581" data-verso-hover="251">stream</span><span class="inter-text">
</span><span class="inter-text">      </span><span class="const token" data-binding="const-process" data-verso-hover="312">process</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1204" data-verso-hover="313">exitCode</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1504" data-verso-hover="315">args</span></code><p>
                  Just as with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if</span></code>, each branch of a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> that is used as a statement in a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code> is implicitly provided with its own <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">do</span></code>.</p>
                <p>
                  There are three possibilities.
One is that no more files remain to be processed, in which case <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> returns the error code unchanged.
Another is that the specified filename is <code class="hl lean inline" data-lean-context="examples"><span class="literal string token" data-binding="" data-verso-hover="316">"-"</span></code>, in which case <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> dumps the contents of the standard input and then processes the remaining filenames.
The final possibility is that an actual filename was specified.
In this case, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fileStream" data-verso-hover="302">fileStream</span></code> is used to attempt to open the file as a POSIX stream.
Its argument is encased in <code>⟨ ... ⟩</code> because a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-System.FilePath" data-verso-hover="304">FilePath</span></code> is a single-field structure that contains a string.
If the file could not be opened, it is skipped, and the recursive call to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> sets the exit code to <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="313">1</span></code>.
If it could, then it is dumped, and the recursive call to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> leaves the exit code unchanged.</p>
                <p>
                  <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> does not need to be marked <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">partial</span></code> because it is structurally recursive.
Each recursive call is provided with the tail of the input list, and all Lean lists are finite.
Thus, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-process" data-verso-hover="312">process</span></code> does not introduce any non-termination.</p>
                </section>
              <section>
                <h3 id="Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Concatenating-Streams--Main">
                  2.4.2.3. Main</h3>
                <p>
                  The final step is to write the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="319">main</span></code> action.
Unlike prior examples, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="319">main</span></code> in <code>feline</code> is a function.
In Lean, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-main" data-verso-hover="319">main</span></code> can have one of three types:</p>
                <ul>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Main1.main" data-verso-hover="249">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-Unit" data-verso-hover="184">Unit</span></code> corresponds to programs that cannot read their command-line arguments and always indicate success with an exit code of <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="313">0</span></code>,</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Main2.main" data-verso-hover="320">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-UInt32" data-verso-hover="314">UInt32</span></code> corresponds to <code>int main(void)</code> in C, for programs without arguments that return exit codes, and</p>
                    </li>
                  <li>
                    <p>
                      <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Main3.main" data-verso-hover="321">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-UInt32" data-verso-hover="314">UInt32</span></code> corresponds to <code>int main(int argc, char **argv)</code> in C, for programs that take arguments and signal success or failure.</p>
                    </li>
                  </ul>
                <p>
                  If no arguments were provided, <code>feline</code> should read from standard input as if it were called with a single <code class="hl lean inline" data-lean-context="examples"><span class="literal string token" data-binding="" data-verso-hover="316">"-"</span></code> argument.
Otherwise, the arguments should be processed one after the other.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1589">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-main" data-verso-hover="319">main</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1989" data-verso-hover="315">args</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-IO" data-verso-hover="2">IO</span><span class="inter-text"> </span><span class="const token" data-binding="const-UInt32" data-verso-hover="314">UInt32</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1636" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1989" data-verso-hover="315">args</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1636" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-process" data-verso-hover="312">process</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="313">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="literal string token" data-binding="" data-verso-hover="316">"-"</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">  </span><span class="const token" data-binding="const-process" data-verso-hover="312">process</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="313">0</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.1989" data-verso-hover="315">args</span></code></section>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Meow___">
                2.4.3. Meow!</h2>
              <div class="paragraph">
                <p>
                  To check whether <code>feline</code> works, the first step is to build it with <span class="shell-command inline"><code class="command">lake build</code></span>.
First off, when called without arguments, it should emit what it receives from standard input.
Check that</p>
                <div class="shell-command block">
                  <code class="command"><code class="prompt">$ </code>echo "It works!" | lake exe feline
</code></div>
                <p>
                  emits <code>It works!</code>.</p>
                </div>
              <div class="paragraph">
                <p>
                  Secondly, when called with files as arguments, it should print them.
If the file <code>test1.txt</code> contains</p>
                <div class="example-file">
                  File: <code>test1.txt</code><code class="line">It's time to find a warm spot</code></div>
                <p>
                  and <code>test2.txt</code> contains</p>
                <div class="example-file">
                  File: <code>test2.txt</code><code class="line">and curl up!</code></div>
                <p>
                  then the command</p>
                <div class="shell-command block">
                  <code class="command"><code class="prompt">$ </code>lake exe feline test1.txt test2.txt</code></div>
                <p>
                  should emit</p>
                <pre>It's time to find a warm spot
and curl up!
</pre></div>
              <p>
                Finally, the <code>-</code> argument should be handled appropriately.</p>
              <div class="shell-command block">
                <code class="command"><code class="prompt">$ </code>echo "and purr" | lake exe feline test1.txt - test2.txt
</code></div>
              <p>
                should yield</p>
              <pre>It's time to find a warm spot
and purr
and curl up!
</pre></section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Hello___-World___--Worked-Example___--cat--Exercise">
                2.4.4. Exercise</h2>
              <p>
                Extend <code>feline</code> with support for usage information.
The extended version should accept a command-line argument <code>--help</code> that causes documentation about the available command-line options to be written to standard output.
</p>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Hello___-World___/Starting-a-Project/#Functional-Programming-in-Lean--Hello___-World___--Starting-a-Project" rel="prev" title="2.3. Starting a Project"><span class="arrow">←</span><span class="where">2.3. Starting a Project</span></a><a class="local-button active" href="Hello___-World___/Additional-Conveniences/#Functional-Programming-in-Lean--Hello___-World___--Additional-Conveniences" rel="next" title="2.5. Additional Conveniences"><span class="where">2.5. Additional Conveniences</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

