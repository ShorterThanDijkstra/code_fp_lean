<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Structures</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="current numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-getting-to-know" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-getting-to-know" checked="checked"></label><span class="number">1.</span> <span class=""><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></span></div>
              <table><tr class="numbered"><td class="num">1.1.</td><td><a href="Getting-to-Know-Lean/Evaluating-Expressions/#evaluating">Evaluating Expressions</a></td></tr><tr class="numbered"><td class="num">1.2.</td><td><a href="Getting-to-Know-Lean/Types/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Types">Types</a></td></tr><tr class="numbered"><td class="num">1.3.</td><td><a href="Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions">Functions and Definitions</a></td></tr><tr class="current numbered"><td class="num">1.4.</td><td><a href="Getting-to-Know-Lean/Structures/#structures">Structures</a></td></tr><tr class="numbered"><td class="num">1.5.</td><td><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns">Datatypes and Patterns</a></td></tr><tr class="numbered"><td class="num">1.6.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">Polymorphism</a></td></tr><tr class="numbered"><td class="num">1.7.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences">Additional Conveniences</a></td></tr><tr class="numbered"><td class="num">1.8.</td><td><a href="Getting-to-Know-Lean/Summary/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-structures" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-structures" checked="checked"></label><span class="number">1.4.</span> <span class="current"><a href="Getting-to-Know-Lean/Structures/#structures">Structures</a></span></div>
              <table><tr class="numbered"><td class="num">1.4.1.</td><td><a href="Getting-to-Know-Lean/Structures/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Structures--Updating-Structures">Updating Structures</a></td></tr><tr class="numbered"><td class="num">1.4.2.</td><td><a href="Getting-to-Know-Lean/Structures/#behind-the-scenes">Behind the Scenes</a></td></tr><tr class="numbered"><td class="num">1.4.3.</td><td><a href="Getting-to-Know-Lean/Structures/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Structures--Exercises">Exercises</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions" rel="prev" title="1.3. Functions and Definitions"><span class="arrow">←</span><span class="where">1.3. Functions and Definitions</span></a><a class="local-button active" href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns" rel="next" title="1.5. Datatypes and Patterns"><span class="where">1.5. Datatypes and Patterns</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              1.4. Structures<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=structures" title="Permalink">🔗</a></span></h1>
            <p>
              The first step in writing a program is usually to identify the problem domain's concepts, and then find suitable representations for them in code.
Sometimes, a domain concept is a collection of other, simpler, concepts.
In that case, it can be convenient to group these simpler components together into a single “package”, which can then be given a meaningful name.
In Lean, this is done using <em>structures</em>, which are analogous to <code>struct</code>s in C or Rust and <code>record</code>s in C#.</p>
            <p>
              Defining a structure introduces a completely new type to Lean that can't be reduced to any other type.
This is useful because multiple structures might represent different concepts that nonetheless contain the same data.
For instance, a point might be represented using either Cartesian or polar coordinates, each being a pair of floating-point numbers.
Defining separate structures prevents API clients from confusing one for another.</p>
            <p>
              Lean's floating-point number type is called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code>, and floating-point numbers are written in the usual notation.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7003">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1.2</span></code><div class="information">
              <pre>1.2 : Float</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7115">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">454.2123215</span></code><div class="information">
              <pre>-454.2123215 : Float</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7229">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span></code><div class="information">
              <pre>0.0 : Float</pre></div>
            <p>
              When floating point numbers are written with the decimal point, Lean will infer the type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code>. If they are written without it, then a type annotation may be necessary.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7325">#check</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span></code><div class="information">
              <pre>0 : Nat</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-7417">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="60">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="unknown token" data-binding="">)</span></code><div class="information">
              <pre>0 : Float</pre></div>
            <p>
              A Cartesian point is a structure with two <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code> fields, called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code>.
This is declared using the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">structure</span></code> keyword.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-7480">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-7496">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-7526">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="64">Repr</span></code><p>
              After this declaration, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code> is a new structure type.
The final line, which says <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-null-7526">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="64">Repr</span></code>, asks Lean to generate code to display values of type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>.
This code is used by <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">#eval</span></code> to render the result of evaluation for consumption by programmers, analogous to the <code>repr</code> function in Python.
It is also possible to override the compiler's generated display code.</p>
            <p>
              The typical way to create a value of a structure type is to provide values for all of its fields inside of curly braces.
The origin of a Cartesian plane is where <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code> are both zero:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-7737">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
              The result of <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-7888" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span></code> looks very much like the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span></code>.</p>
            <div class="information">
              <pre>{ x := 0.000000, y := 0.000000 }</pre></div>
            <p>
              Because structures exist to “bundle up” a collection of data, naming it and treating it as a single unit, it is also important to be able to extract the individual fields of a structure.
This is done using dot notation, as in C, Python, Rust, or JavaScript.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9895" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code><div class="information">
              <pre>0.000000</pre></div>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9990" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code><div class="information">
              <pre>0.000000</pre></div>
            <div class="paragraph">
              <p>
                This can be used to define functions that take structures as arguments.
For instance, addition of points is performed by adding the underlying coordinate values.
It should be the case that</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-10280" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-addPoints" data-verso-hover="67">addPoints</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1.5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">32</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="typed token" data-binding="" data-verso-hover="60">8</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                yields</p>
              <div class="information">
                <pre>{ x := -6.500000, y := 32.200000 }</pre></div>
              </div>
            <p>
              The function itself takes two <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>s as arguments, called <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.6194" data-verso-hover="68">p1</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.6196" data-verso-hover="68">p2</span></code>.
The resulting point is based on the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span></code> fields of both <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.6194" data-verso-hover="68">p1</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.6196" data-verso-hover="68">p2</span></code>:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10076">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-addPoints" data-verso-hover="67">addPoints</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6194" data-verso-hover="68">p1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6196" data-verso-hover="68">p2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6194" data-verso-hover="68">p1</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6196" data-verso-hover="68">p2</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6194" data-verso-hover="68">p1</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.6196" data-verso-hover="68">p2</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
              Similarly, the distance between two points, which is the square root of the sum of the squares of the differences in their <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code> components, can be written:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11678">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-distance" data-verso-hover="69">distance</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="68">p1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9414" data-verso-hover="68">p2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Float.sqrt" data-verso-hover="70">Float.sqrt</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9414" data-verso-hover="68">p2</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="68">p1</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2.0</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9414" data-verso-hover="68">p2</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9412" data-verso-hover="68">p1</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">^</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2.0</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span></code><p>
              For example, the distance between <code class="math inline">(1, 2)</code> and <code class="math inline">(5, -1)</code> is <code class="math inline">5</code>:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11875" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-distance" data-verso-hover="69">distance</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">5.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">-</span><span class="unknown token" data-binding="">1.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><div class="information">
              <pre>5.000000</pre></div>
            <p>
              Multiple structures may have fields with the same names.
A three-dimensional point datatype may share the fields <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point3D.x" data-verso-hover="71">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point3D.y" data-verso-hover="72">y</span></code>, and be instantiated with the same field names:</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-10387">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D" data-verso-hover="73">Point3D</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10405">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Point3D.x" data-verso-hover="71">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Point3D.y" data-verso-hover="72">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Point3D.z" data-verso-hover="74">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-10447">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="64">Repr</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-10505">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin3D" data-verso-hover="75">origin3D</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D" data-verso-hover="73">Point3D</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point3D.z" data-verso-hover="66">z</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
              This means that the structure's expected type must be known in order to use the curly-brace syntax.
If the type is not known, Lean will not be able to instantiate the structure.
For example,</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-8268">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="unknown token" data-binding="">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
              leads to the error</p>
            <div class="error">
              <pre>invalid {...} notation, expected type is not known</pre></div>
            <p>
              As usual, the situation can be remedied by providing a type annotation.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-8413">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span></code><div class="information">
              <pre>{ x := 0.0, y := 0.0 } : Point</pre></div>
            <p>
              To make programs more concise, Lean also allows the structure type annotation inside the curly braces.</p>
            <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-8572">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">0.0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">}</span></code><div class="information">
              <pre>{ x := 0.0, y := 0.0 } : Point</pre></div>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Structures--Updating-Structures">
                1.4.1. Updating Structures</h2>
              <p>
                Imagine a function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.zeroX" data-verso-hover="76">zeroX</span></code> that replaces the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.Point.x" data-verso-hover="66">x</span></code> field of a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.Point" data-verso-hover="63">Point</span></code> with <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="60">0</span></code>.
In most programming language communities, this sentence would mean that the memory location pointed to by <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> was to be overwritten with a new value.
However, Lean is a functional programming language.
In functional programming communities, what is almost always meant by this kind of statement is that a fresh <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code> is allocated with the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> field pointing to the new value, and all other fields pointing to the original values from the input.
One way to write <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Oops.zeroX" data-verso-hover="76">zeroX</span></code> is to follow this description literally, filling out the new value for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and manually transferring <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8677">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.zeroX" data-verso-hover="76">zeroX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5895" data-verso-hover="68">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">0</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Oops.Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5895" data-verso-hover="68">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Oops.Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                This style of programming has drawbacks, however.
First off, if a new field is added to a structure, then every site that updates any field at all must be updated, causing maintenance difficulties.
Secondly, if the structure contains multiple fields with the same type, then there is a real risk of copy-paste coding leading to field contents being duplicated or switched.
Finally, the program becomes long and bureaucratic.</p>
              <p>
                Lean provides a convenient syntax for replacing some fields in a structure while leaving the others alone.
This is done by using the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">with</span></code> keyword in a structure initialization.
The source of unchanged fields occurs before the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">with</span></code>, and the new fields occur after.
For example, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-zeroX" data-verso-hover="76">zeroX</span></code> can be written with only the new <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> value:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-8784">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-zeroX" data-verso-hover="76">zeroX</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.5911" data-verso-hover="68">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.5911" data-verso-hover="68">p</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-8821">with</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                Remember that this structure update syntax does not modify existing values—it creates new values that share some fields with old values.
Given the point <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9004">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">4.3</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="unknown token" data-binding="">3.4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                evaluating it, then evaluating an update of it using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-zeroX" data-verso-hover="76">zeroX</span></code>, then evaluating it again yields the original value:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9177" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span></code><div class="information">
                <pre>{ x := 4.300000, y := 3.400000 }</pre></div>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9323" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-zeroX" data-verso-hover="76">zeroX</span><span class="inter-text"> </span><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span></code><div class="information">
                <pre>{ x := 0.000000, y := 3.400000 }</pre></div>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9177" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span></code><div class="information">
                <pre>{ x := 4.300000, y := 3.400000 }</pre></div>
              <p>
                One consequence of the fact that structure updates do not modify the original structure is that it becomes easier to reason about cases where the new value is computed from the old one.
All references to the old structure continue to refer to the same field values in all of the new values provided.</p>
              </section>
            <section>
              <h2 id="behind-the-scenes">
                1.4.2. Behind the Scenes<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=behind-the-scenes" title="Permalink">🔗</a></span></h2>
              <p>
                Every structure has a <em>constructor</em>.
Here, the term “constructor” may be a source of confusion.
Unlike constructors in languages such as Java or Python, constructors in Lean are not arbitrary code to be run when a datatype is initialized.
Instead, constructors simply gather the data to be stored in the newly-allocated data structure.
It is not possible to provide a custom constructor that pre-processes data or rejects invalid arguments.
This is really a case of the word “constructor” having different, but related, meanings in the two contexts.</p>
              <p>
                By default, the constructor for a structure named <code>S</code> is named <code>S.mk</code>.
Here, <code>S</code> is a namespace qualifier, and <code>mk</code> is the name of the constructor itself.
Instead of using curly-brace initialization syntax, the constructor can also be applied directly.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-10977">#check</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.mk" data-verso-hover="78">Point.mk</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1.5</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2.8</span></code><p>
                However, this is not generally considered to be good Lean style, and Lean even returns its feedback using the standard structure initializer syntax.</p>
              <div class="information">
                <pre>{ x := 1.5, y := 2.8 } : Point</pre></div>
              <p>
                Constructors have function types, which means they can be used anywhere that a function is expected.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.mk" data-verso-hover="78">Point.mk</span></code> is a function that accepts two <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code>s (respectively <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span></code>) and returns a new <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-9470">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Point.mk" data-verso-hover="78">Point.mk</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                <pre>Point.mk : Float → Float → Point</pre></div>
              <p>
                To override a structure's constructor name, write it with two colons at the beginning.
For instance, to use <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ctor.Point.point" data-verso-hover="79">Point.point</span></code> instead of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.mk" data-verso-hover="78">Point.mk</span></code>, write:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-10630">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ctor.Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-10646">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Ctor.Point.point" data-verso-hover="79">point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Ctor.Point.x" data-verso-hover="61">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Ctor.Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-null-10687">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="64">Repr</span></code><p>
                In addition to the constructor, an accessor function is defined for each field of a structure.
These have the same name as the field, in the structure's namespace.
For <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>, accessor functions <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="61">Point.x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.y" data-verso-hover="62">Point.y</span></code> are generated.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-9584">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">Point.x</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                <pre>Point.x : Point → Float</pre></div>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-9696">#check</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">Point.y</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                <pre>Point.y : Point → Float</pre></div>
              <p>
                In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span></code> in the prior definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-addPoints" data-verso-hover="67">addPoints</span></code> is converted into a call to the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span></code> accessor.
That is, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9895" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-9793" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">Point.x</span><span class="inter-text"> </span><span class="const token" data-binding="const-origin" data-verso-hover="65">origin</span></code> both yield</p>
              <div class="information">
                <pre>0.000000</pre></div>
              <p>
                Accessor dot notation is usable with more than just structure fields.
It can also be used for functions that take any number of arguments.
More generally, accessor notation has the form <code>TARGET.f ARG1 ARG2 ...</code>.
If <code>TARGET</code> has type <code>T</code>, the function named <code>T.f</code> is called.
<code>TARGET</code> becomes its leftmost argument of type <code>T</code>, which is often but not always the first one, and <code>ARG1 ARG2 ...</code> are provided in order as the remaining arguments.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.append" data-verso-hover="9">String.append</span></code> can be invoked from a string with accessor notation, even though <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String" data-verso-hover="35">String</span></code> is not a structure with an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-String.append" data-verso-hover="9">append</span></code> field.</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11110" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="80">"one string"</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-String.append" data-verso-hover="9">append</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="81">" and another"</span></code><div class="information">
                <pre>"one string and another"</pre></div>
              <p>
                In that example, <code>TARGET</code> represents <code class="hl lean inline" data-lean-context="examples"><span class="literal string token" data-binding="" data-verso-hover="80">"one string"</span></code> and <code>ARG1</code> represents <code class="hl lean inline" data-lean-context="examples"><span class="literal string token" data-binding="" data-verso-hover="81">" and another"</span></code>.</p>
              <p>
                The function <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.modifyBoth" data-verso-hover="82">Point.modifyBoth</span></code> (that is, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.modifyBoth" data-verso-hover="82">modifyBoth</span></code> defined in the <code>Point</code> namespace) applies a function to both fields in a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code>:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-11206">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.modifyBoth" data-verso-hover="82">Point.modifyBoth</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9338" data-verso-hover="83">f</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.9340" data-verso-hover="68">p</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9338" data-verso-hover="83">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9340" data-verso-hover="68">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.x" data-verso-hover="61">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9338" data-verso-hover="83">f</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.9340" data-verso-hover="68">p</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.y" data-verso-hover="62">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code><p>
                Even though the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code> argument comes after the function argument, it can be used with dot notation as well:</p>
              <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-11535" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Point.modifyBoth" data-verso-hover="82">modifyBoth</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float.floor" data-verso-hover="84">Float.floor</span></code><div class="information">
                <pre>{ x := 4.000000, y := 3.000000 }</pre></div>
              <p>
                In this case, <code>TARGET</code> represents <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-fourAndThree" data-verso-hover="77">fourAndThree</span></code>, while <code>ARG1</code> is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float.floor" data-verso-hover="84">Float.floor</span></code>.
This is because the target of the accessor notation is used as the first argument in which the type matches, not necessarily the first argument.</p>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Structures--Exercises">
                1.4.3. Exercises</h2>
              <ul>
                <li>
                  <p>
                    Define a structure named <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ex.RectangularPrism" data-verso-hover="85">RectangularPrism</span></code> that contains the height, width, and depth of a rectangular prism, each as a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Define a function named <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ex.volume" data-verso-hover="86">volume</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Ex.RectangularPrism" data-verso-hover="85">RectangularPrism</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code> that computes the volume of a rectangular prism.</p>
                  </li>
                <li>
                  <p>
                    Define a structure named <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ex.Segment" data-verso-hover="87">Segment</span></code> that represents a line segment by its endpoints, and define a function <code>length : Segment → Float</code> that computes the length of a line segment. <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ex.Segment" data-verso-hover="87">Segment</span></code> should have at most two fields.</p>
                  </li>
                <li>
                  <p>
                    Which names are introduced by the declaration of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Ex.RectangularPrism" data-verso-hover="85">RectangularPrism</span></code>?</p>
                  </li>
                <li>
                  <p>
                    Which names are introduced by the following declarations of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Hamster" data-verso-hover="88">Hamster</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Book" data-verso-hover="89">Book</span></code>? What are their types?</p>
                  <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-11986">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Hamster" data-verso-hover="88">Hamster</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12004">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Hamster.name" data-verso-hover="90">name</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Hamster.fluffy" data-verso-hover="91">fluffy</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span></code><code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.structureTk-12082">structure</span><span class="inter-text"> </span><span class="const token" data-binding="const-Book" data-verso-hover="89">Book</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-12097">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Book.makeBook" data-verso-hover="92">makeBook</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Book.title" data-verso-hover="93">title</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Book.author" data-verso-hover="94">author</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-Book.price" data-verso-hover="95">price</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Float" data-verso-hover="59">Float</span></code></li>
                </ul>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions" rel="prev" title="1.3. Functions and Definitions"><span class="arrow">←</span><span class="where">1.3. Functions and Definitions</span></a><a class="local-button active" href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns" rel="next" title="1.5. Datatypes and Patterns"><span class="where">1.5. Datatypes and Patterns</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

