<!DOCTYPE html>
<html>
  <head>
    <script>
      (function(){
  const {protocol:proto, host:hostName, pathname:path, search:srch, hash:hsh} = window.location;
  if (!(path.endsWith("/") || path.endsWith(".html"))) {
    window.location.replace(`${proto}//${hostName}${path}/${srch}${hsh}`);
  }
})()</script>
    <base href="./../../"><meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <title>Additional Conveniences</title><link rel="stylesheet" href="book.css">
    <script>
      const __versoSiteRoot = document.baseURI;</script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <script src="-verso-data/katex/katex.js"></script>
    <script src="-verso-data/katex/math.js"></script>
    <script src="-verso-data/popper.js"></script>
    <script src="-verso-data/tippy.js"></script>
    <link rel="stylesheet" href="static/theme.css">
    <link rel="stylesheet" href="static/fonts/source-serif/source-serif-text.css">
    <link rel="stylesheet" href="static/fonts/source-code-pro/source-code-pro.css">
    <link rel="stylesheet" href="static/fonts/source-sans/source-sans-3.css">
    <link rel="stylesheet" href="static/fonts/noto-sans-mono/noto-sans-mono.css">
    <link rel="stylesheet" href="-verso-data/katex/katex.css">
    <link rel="stylesheet" href="-verso-data/tippy-border.css">
    <style>
div.paragraph > .eval-steps:not(:first-child), div.paragraph > .eval-steps:not(:first-child) > * {
  margin-top: 0.5rem;
}

div.paragraph > .eval-steps:not(:last-child), div.paragraph > .eval-steps:not(:last-child) > * {
  margin-bottom: 0.5rem;
}

.eval-steps .hl.lean.block {
  margin-top: 0.25em;
  margin-bottom: 0.25em;
}
</style><style>
.shell-command {

}
.shell-command.inline > * {
  display: inline;
  white-space: pre;
}
.shell-command.inline .command::before {
  content: "$ ";
  font-weight: 600;
}
</style><style>
.shell-command {

}
.shell-command.block > * {
  display: block;
  white-space: pre;
}
.shell-command .command .prompt {
  font-weight: 600;
}

div.paragraph > .shell-command:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-command:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>

.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info .token:not(.tactic-state):not(.tactic-state *), .hl.lean .has-info .inter-text:not(.tactic-state):not(.tactic-state *) {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error :not(.tactic-state):not(.tactic-state *){
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info :not(.tactic-state):not(.tactic-state *) {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}

.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}

</style><style>
.example-file {
  white-space: normal;
  font-family: var(--verso-structure-font-family);
  margin: 1rem;
  width: fit-content;
  border: 1px solid #ddd;
  padding: 0.5rem;

  /* These are necessary for the container to behave nicely on mobile */
  overflow-x: auto;
  max-width: 100%;
  box-sizing: border-box;
}
.example-file::before {
  counter-reset: linenumber;
}
.example-file > .line {
  display: block;
  white-space: pre;
  counter-increment: linenumber;
  font-family: var(--verso-code-font-family);
}
.example-file > .line::before {
  -webkit-user-select: none;
  display: inline-block;
  content: counter(linenumber);
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
.example-file > .line::after {
  -webkit-user-select: none;
  display: inline-block;
  content: "⏎";
  opacity: 0;
}
.example-file > .line:hover::after {
  opacity: 1;
}
.example-file > .line:hover, .example-file > .line:hover::before {
  background-color: #eee;
}
.example-file > .empty {
  display: block;
  white-space: pre;
  font-family: var(--verso-code-font-family);
  font-style: italic;
}
.example-file > .empty::before {
  -webkit-user-select: none;
  display: inline-block;
  content: "";
  border-right: 1px solid #ddd;
  width: 2em;
  padding-right: 0.25em;
  margin-right: 0.25em;
  font-family: var(--verso-code-font-family);
  text-align: right;
}
</style><style>
table.tabular {
  margin: auto;
  border-spacing: 1rem;
}
table.tabular.left-align {
  margin-right: auto;
  margin-left: 0;
}
table.tabular.center-align {
  margin: auto;
}
table.tabular.right-align {
  margin-left auto;
  margin-right: 0;
}
table.tabular td, table.tabular th {
  text-align: left;
  vertical-align: top;
}
table.tabular td > p:first-child, table.tabular th > p:first-child {
  margin-top: 0;
}
table.tabular td > p:last-child, table.tabular th > p:first-child {
  margin-bottom: 0;
}
</style><style>
.shell-commands {

}
.shell-commands > * {
  display: block;
  white-space: pre;
}
.shell-commands .command::before {
  content: "$ ";
  font-weight: 600;
}

div.paragraph > .shell-commands:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .shell-commands:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><style>
.eq-steps .hl.lean.block {
  background-color: #f6f7f6;
  padding: 1rem;
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
.eq-steps .reason {
  font-style: italic;
  margin-left: 2.5em;
  display: flex;
}
.eq-steps .reason::before {
  content: "={";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-right: 0.5em;
  align-self: center;
}
.eq-steps .reason > p {
  margin: 0;
  max-width: 25em;
  align-self: center;
}
.eq-steps .reason::after {
  content: "}=";
  font-family: var(--verso-code-font-family);
  font-style: normal;
  font-weight: 600;
  margin-left: 1em;
  align-self: center;
}
</style><style>
div.paragraph > .eq-steps:not(:first-child) {
  margin-top: 0.5rem;
}

div.paragraph > .eq-steps:not(:last-child) {
  margin-bottom: 0.5rem;
}
</style><script>
      
window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      function hideParentTooltips(element) {
        let parent = element.parentElement;
        while (parent) {
          const tippyInstance = parent._tippy;
          if (tippyInstance) {
            tippyInstance.hide();
          }
          parent = parent.parentElement;
        }
      }



      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        /* theme: "lean", */
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        /* ignoreAttributes: true, */
        followCursor: 'initial',
        onShow(inst) {
          if (inst.reference.className == 'tactic') {

            const toggle = inst.reference.querySelector("input.tactic-toggle");
            if (toggle && toggle.checked) {
              return false;
            }
            hideParentTooltips(inst.reference);
            //if (blockedByTippy(inst.reference)) { return false; }

          } else if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          if (tgt.className == 'tactic') {
            const state = tgt.querySelector(".tactic-state").cloneNode(true);
            state.style.display = "block";
            content.appendChild(state);
            content.style.display = "block";
            content.className = "hl lean popup";
          } else {
            content.className = "hl lean";
            content.style.display = "block";
            content.style.maxHeight = "300px";
            content.style.overflowY = "auto";
            content.style.overflowX = "hidden";
            const hoverId = tgt.dataset.versoHover;
            const hoverInfo = tgt.querySelector(".hover-info");
            if (hoverId) { // Docstrings from the table
              // TODO stop doing an implicit conversion from string to number here
              let data = versoDocData[hoverId];
              if (data) {
                const info = document.createElement("span");
                info.className = "hover-info";
                info.style.display = "block";
                info.innerHTML = data;
                content.appendChild(info);
                /* Render docstrings - TODO server-side */
                if ('undefined' !== typeof marked) {
                    for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                        const str = d.innerText;
                        const html = marked.parse(str);
                        const rendered = document.createElement("div");
                        rendered.classList.add("docstring");
                        rendered.innerHTML = html;
                        d.parentNode.replaceChild(rendered, d);
                    }
                }
              } else {
                content.innerHTML = "Failed to load doc ID: " + hoverId;
              }
            } else if (hoverInfo) { // The inline info, still used for compiler messages
              content.appendChild(hoverInfo.cloneNode(true));
            }
          }
          return content;
        }
      };



      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      document.querySelectorAll('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token').forEach(element => {
        element.setAttribute('data-tippy-theme', 'lean');
      });
      document.querySelectorAll('.hl.lean .has-info.warning').forEach(element => {
        element.setAttribute('data-tippy-theme', 'warning message');
      });
      document.querySelectorAll('.hl.lean .has-info.info').forEach(element => {
        element.setAttribute('data-tippy-theme', 'info message');
      });
      document.querySelectorAll('.hl.lean .has-info.error').forEach(element => {
        element.setAttribute('data-tippy-theme', 'error message');
      });
      document.querySelectorAll('.hl.lean .tactic').forEach(element => {
        element.setAttribute('data-tippy-theme', 'tactic');
      });
      let insts = tippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token, .hl.lean .has-info, .hl.lean .tactic', defaultTippyProps);



      /*
      tippy('.hl.lean .tactic', {
        allowHtml: true,

        onHide(any) { return false; },
        trigger: "click",

        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
      */
  });
}
</script>
    </head>
  <body>
    <header>
      <div class="header-logo-wrapper">
        <a href="" id="logo"><img src="static/lean_logo.svg"></a></div>
      <div class="header-title-wrapper">
        <a href="" class="header-title"><h1>
            Functional Programming in Lean</h1>
          </a></div>
      </header>
    <label for="toggle-toc" id="toggle-toc-click"><span class="line line1"></span><span class="line line2"></span><span class="line line3"></span></label><div class="with-toc">
      <div class="toc-backdrop" onclick="document.getElementById('toggle-toc-click')?.click()"></div>
      <nav id="toc">
        <input type="checkbox" id="toggle-toc"><div class="first">
          <a href="" class="toc-title"><h1>
              Functional Programming in Lean</h1>
            </a><div class="split-tocs">
            <div class="split-toc book">
              <div class="title">
                <label for="--verso-manual-toc-----bookRoot" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-----bookRoot"></label><span class="">Table of Contents</span></div>
              <table><tr class="unnumbered"><td class="num"><td><a href="Introduction/#Functional-Programming-in-Lean--Introduction">Introduction</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Acknowledgments/#Functional-Programming-in-Lean--Acknowledgments">Acknowledgments</a></td></tr><tr class="current numbered"><td class="num">1.</td><td><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></td></tr><tr class="numbered"><td class="num">2.</td><td><a href="Hello___-World___/#hello-world">Hello, World!</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Propositions___-Proofs___-and-Indexing/#props-proofs-indexing">Interlude: Propositions, Proofs, and Indexing</a></td></tr><tr class="numbered"><td class="num">3.</td><td><a href="Overloading-and-Type-Classes/#Functional-Programming-in-Lean--Overloading-and-Type-Classes">Overloading and Type Classes</a></td></tr><tr class="numbered"><td class="num">4.</td><td><a href="Monads/#Functional-Programming-in-Lean--Monads">Monads</a></td></tr><tr class="numbered"><td class="num">5.</td><td><a href="Functors___-Applicative-Functors___-and-Monads/#Functional-Programming-in-Lean--Functors___-Applicative-Functors___-and-Monads">Functors, Applicative Functors, and Monads</a></td></tr><tr class="numbered"><td class="num">6.</td><td><a href="Monad-Transformers/#Functional-Programming-in-Lean--Monad-Transformers">Monad Transformers</a></td></tr><tr class="numbered"><td class="num">7.</td><td><a href="Programming-with-Dependent-Types/#Functional-Programming-in-Lean--Programming-with-Dependent-Types">Programming with Dependent Types</a></td></tr><tr class="unnumbered"><td class="num"><td><a href="Interlude___-Tactics___-Induction___-and-Proofs/#Functional-Programming-in-Lean--Interlude___-Tactics___-Induction___-and-Proofs">Interlude: Tactics, Induction, and Proofs</a></td></tr><tr class="numbered"><td class="num">8.</td><td><a href="Programming___-Proving___-and-Performance/#Functional-Programming-in-Lean--Programming___-Proving___-and-Performance">Programming, Proving, and Performance</a></td></tr><tr class="numbered"><td class="num">9.</td><td><a href="Next-Steps/#next-steps">Next Steps</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-getting-to-know" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-getting-to-know" checked="checked"></label><span class="number">1.</span> <span class=""><a href="Getting-to-Know-Lean/#getting-to-know">Getting to Know Lean</a></span></div>
              <table><tr class="numbered"><td class="num">1.1.</td><td><a href="Getting-to-Know-Lean/Evaluating-Expressions/#evaluating">Evaluating Expressions</a></td></tr><tr class="numbered"><td class="num">1.2.</td><td><a href="Getting-to-Know-Lean/Types/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Types">Types</a></td></tr><tr class="numbered"><td class="num">1.3.</td><td><a href="Getting-to-Know-Lean/Functions-and-Definitions/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Functions-and-Definitions">Functions and Definitions</a></td></tr><tr class="numbered"><td class="num">1.4.</td><td><a href="Getting-to-Know-Lean/Structures/#structures">Structures</a></td></tr><tr class="numbered"><td class="num">1.5.</td><td><a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns">Datatypes and Patterns</a></td></tr><tr class="numbered"><td class="num">1.6.</td><td><a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">Polymorphism</a></td></tr><tr class="current numbered"><td class="num">1.7.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences">Additional Conveniences</a></td></tr><tr class="numbered"><td class="num">1.8.</td><td><a href="Getting-to-Know-Lean/Summary/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Summary">Summary</a></td></tr></table></div>
            <div class="split-toc">
              <div class="title">
                <label for="--verso-manual-toc-Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences" class="toggle-split-toc"><input type="checkbox" class="toggle-split-toc" id="--verso-manual-toc-Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences" checked="checked"></label><span class="number">1.7.</span> <span class="current"><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences">Additional Conveniences</a></span></div>
              <table><tr class="numbered"><td class="num">1.7.1.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Automatic-Implicit-Parameters">Automatic Implicit Parameters</a></td></tr><tr class="numbered"><td class="num">1.7.2.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Pattern-Matching-Definitions">Pattern-Matching Definitions</a></td></tr><tr class="numbered"><td class="num">1.7.3.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Local-Definitions">Local Definitions</a></td></tr><tr class="numbered"><td class="num">1.7.4.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Type-Inference">Type Inference</a></td></tr><tr class="numbered"><td class="num">1.7.5.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#simultaneous-matching">Simultaneous Matching</a></td></tr><tr class="numbered"><td class="num">1.7.6.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Natural-Number-Patterns">Natural Number Patterns</a></td></tr><tr class="numbered"><td class="num">1.7.7.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Anonymous-Functions">Anonymous Functions</a></td></tr><tr class="numbered"><td class="num">1.7.8.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Namespaces">Namespaces</a></td></tr><tr class="numbered"><td class="num">1.7.9.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--if-let">if let</a></td></tr><tr class="numbered"><td class="num">1.7.10.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Positional-Structure-Arguments">Positional Structure Arguments</a></td></tr><tr class="numbered"><td class="num">1.7.11.</td><td><a href="Getting-to-Know-Lean/Additional-Conveniences/#string-interpolation">String Interpolation</a></td></tr></table></div>
            </div>
          </div>
        <div class="last">
          <ul id="meta-links">
            <li>
              <a href="https://github.com/leanprover/fp-lean">Source Code</a></li>
            <li>
              <a href="https://github.com/leanprover/fp-lean/issues">Report Issues</a></li>
            </ul>
          </div>
        </nav>
      <main><div class="content-wrapper">
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Polymorphism/#polymorphism" rel="prev" title="1.6. Polymorphism"><span class="arrow">←</span><span class="where">1.6. Polymorphism</span></a><a class="local-button active" href="Getting-to-Know-Lean/Summary/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Summary" rel="next" title="1.8. Summary"><span class="where">1.8. Summary</span><span class="arrow">→</span></a></nav>
          <section>
            <h1>
              1.7. Additional Conveniences</h1>
            <p>
              Lean contains a number of convenience features that make programs much more concise.</p>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Automatic-Implicit-Parameters">
                1.7.1. Automatic Implicit Parameters</h2>
              <div class="paragraph">
                <p>
                  When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit parameters.
Instead, they can simply be mentioned.
If Lean can determine their type, then they are automatically inserted as implicit parameters.
In other words, the previous definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-22621">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.33376" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.33379" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33376" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-22670" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33379" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-22670" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33422" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33423" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-BetterPlicity.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.33423" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                  can be written without <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.33376" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34854">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-AutoImpl.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.84797" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96816" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34891" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84797" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34891" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84839" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84840" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-AutoImpl.length" data-verso-hover="139">length</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84840" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                  This can greatly simplify highly polymorphic definitions that take many implicit parameters.</p>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Pattern-Matching-Definitions">
                1.7.2. Pattern-Matching Definitions</h2>
              <p>
                When defining functions with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code>, it is quite common to name an argument and then immediately use it with pattern matching.
For instance, in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-AutoImpl.length" data-verso-hover="139">length</span></code>, the argument <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.84797" data-verso-hover="137">xs</span></code> is used only in <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code>.
In these situations, the cases of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> expression can be written directly, without naming the argument at all.</p>
              <div class="paragraph">
                <p>
                  The first step is to move the arguments' types to the right of the colon, so the return type is a function type.
For instance, the type of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-MatchDef.length" data-verso-hover="202">length</span></code> is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84988" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.
Then, replace the <code>:=</code> with each case of the pattern match:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-35087">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-MatchDef.length" data-verso-hover="202">length</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84988" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85041" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85042" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-MatchDef.length" data-verso-hover="202">length</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85042" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                  This syntax can also be used to define functions that take more than one argument.
In this case, their patterns are separated by commas.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-drop" data-verso-hover="203">drop</span></code> takes a number <code class="math inline">n</code> and a list, and returns the list after removing the first <code class="math inline">n</code> entries.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-35279">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-drop" data-verso-hover="203">drop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85197" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85197" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85224" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85224" data-verso-hover="137">xs</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85271" data-verso-hover="5">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85272" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85273" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-drop" data-verso-hover="203">drop</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85271" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85273" data-verso-hover="137">xs</span></code></div>
              <div class="paragraph">
                <p>
                  Named arguments and patterns can also be used in the same definition.
For instance, a function that takes a default value and an optional value, and returns the default when the optional value is <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span></code>, can be written:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-35439">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-fromOption" data-verso-hover="204">fromOption</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.85542" data-verso-hover="121">default</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85197" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85197" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85197" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85542" data-verso-hover="121">default</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85575" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85575" data-verso-hover="121">x</span></code><p>
                  This function is called <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Option.getD" data-verso-hover="205">Option.getD</span></code> in the standard library, and can be called with dot notation:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"salmonberry"</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-35613" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="206">"salmonberry"</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Option.getD" data-verso-hover="205">getD</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="207">""</span></code><div class="information">
                  <pre>"salmonberry"</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">""</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-35720" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Option.getD" data-verso-hover="205">getD</span><span class="inter-text"> </span><span class="literal string token" data-binding="" data-verso-hover="207">""</span></code><div class="information">
                  <pre>""</pre></div>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Local-Definitions">
                1.7.3. Local Definitions</h2>
              <p>
                It is often useful to name intermediate steps in a computation.
In many cases, intermediate values represent useful concepts all on their own, and naming them explicitly can make the program easier to read.
In other cases, the intermediate value is used more than once.
As in most other languages, writing down the same code twice in Lean causes it to be computed twice, while saving the result in a variable leads to the result of the computation being saved and re-used.</p>
              <div class="paragraph">
                <p>
                  For instance, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BadUnzip.unzip" data-verso-hover="208">unzip</span></code> is a function that transforms a list of pairs into a pair of lists.
When the list of pairs is empty, then the result of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BadUnzip.unzip" data-verso-hover="208">unzip</span></code> is a pair of empty lists.
When the list of pairs has a pair at its head, then the two fields of the pair are added to the result of unzipping the rest of the list.
This definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-BadUnzip.unzip" data-verso-hover="208">unzip</span></code> follows that description exactly:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-35860">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-BadUnzip.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86349" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86349" data-verso-hover="113">β</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.85831" data-verso-hover="121">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85832" data-verso-hover="190">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85833" data-verso-hover="209">xys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.85831" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-BadUnzip.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85833" data-verso-hover="209">xys</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.fst" data-verso-hover="210">fst</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85832" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-BadUnzip.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.85833" data-verso-hover="209">xys</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.snd" data-verso-hover="211">snd</span><span class="unknown token" data-binding="">)</span></code><p>
                  Unfortunately, there is a problem: this code is slower than it needs to be.
Each entry in the list of pairs leads to two recursive calls, which makes this function take exponential time.
However, both recursive calls will have the same result, so there is no reason to make the recursive call twice.</p>
                </div>
              <div class="paragraph">
                <p>
                  In Lean, the result of the recursive call can be named, and thus saved, using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code>.
Local definitions with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> resemble top-level definitions with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code>: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following <code>:=</code>.
After the local definition, the expression in which the local definition is available (called the <em>body</em> of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code>-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> keyword.
A local definition with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-unzip" data-verso-hover="208">unzip</span></code> looks like this:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-36090">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86349" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86349" data-verso-hover="113">β</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86125" data-verso-hover="121">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86126" data-verso-hover="190">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86127" data-verso-hover="209">xys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-36185" data-verso-hover="212">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86133" data-verso-hover="213">unzipped</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86349" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86127" data-verso-hover="209">xys</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86125" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86133" data-verso-hover="213">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.fst" data-verso-hover="210">fst</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86126" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86133" data-verso-hover="213">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.snd" data-verso-hover="211">snd</span><span class="unknown token" data-binding="">)</span></code><p>
                  To use <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> on a single line, separate the local definition from the body with a semicolon.</p>
                </div>
              <div class="paragraph">
                <p>
                  Local definitions with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> may also use pattern matching when one pattern is enough to match all cases of a datatype.
In the case of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-unzip" data-verso-hover="208">unzip</span></code>, the result of the recursive call is a pair.
Because pairs have only a single constructor, the name <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.86133" data-verso-hover="213">unzipped</span></code> can be replaced with a pair pattern:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-36671">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-WithPattern.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86672" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86674" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86672" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86674" data-verso-hover="113">β</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86751" data-verso-hover="121">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86752" data-verso-hover="190">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86753" data-verso-hover="209">xys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-36766" data-verso-hover="212">let</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86782" data-verso-hover="137">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86783" data-verso-hover="189">ys</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86672" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86674" data-verso-hover="113">β</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-WithPattern.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86753" data-verso-hover="209">xys</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86751" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86782" data-verso-hover="137">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86752" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86783" data-verso-hover="189">ys</span><span class="unknown token" data-binding="">)</span></code><p>
                  Judicious use of patterns with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> can make code easier to read, compared to writing the accessor calls by hand.</p>
                </div>
              <div class="paragraph">
                <p>
                  The biggest difference between <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code> is that recursive <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> definitions must be explicitly indicated by writing <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let rec</span></code>.
For instance, one way to reverse a list involves a recursive helper function, as in this definition:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-36400">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-reverse" data-verso-hover="214">reverse</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86364" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-group-36442">let</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-group-36442">rec</span><span class="inter-text"> </span><span class="const token" data-binding="const-reverse.helper" data-verso-hover="215">helper</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86347" data-verso-hover="113">α</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86403" data-verso-hover="137">soFar</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86403" data-verso-hover="137">soFar</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86430" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86431" data-verso-hover="137">ys</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86432" data-verso-hover="137">soFar</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-reverse.helper" data-verso-hover="215">helper</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86431" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.86430" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86432" data-verso-hover="137">soFar</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-reverse.helper" data-verso-hover="215">helper</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.86364" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span></code><p>
                  The helper function walks down the input list, moving one entry at a time over to <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.86403" data-verso-hover="137">soFar</span></code>.
When it reaches the end of the input list, <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.86403" data-verso-hover="137">soFar</span></code> contains a reversed version of the input.</p>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Type-Inference">
                1.7.4. Type Inference</h2>
              <div class="paragraph">
                <p>
                  In many situations, Lean can automatically determine an expression's type.
In these cases, explicit types may be omitted from both top-level definitions (with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code>) and local definitions (with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code>).
For example, the recursive call to <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-NT.unzip" data-verso-hover="208">unzip</span></code> does not need an annotation:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-36956">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NT.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87066" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87068" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87066" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87068" data-verso-hover="113">β</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87137" data-verso-hover="121">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87138" data-verso-hover="190">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87139" data-verso-hover="209">xys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-37051" data-verso-hover="212">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87142" data-verso-hover="213">unzipped</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-NT.unzip" data-verso-hover="208">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87139" data-verso-hover="209">xys</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87137" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87142" data-verso-hover="213">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.fst" data-verso-hover="210">fst</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87138" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87142" data-verso-hover="213">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.snd" data-verso-hover="211">snd</span><span class="unknown token" data-binding="">)</span></code></div>
              <p>
                As a rule of thumb, omitting the types of literal values (like strings and numbers) usually works, although Lean may pick a type for literal numbers that is more specific than the intended type.
Lean can usually determine a type for a function application, because it already knows the argument types and the return type.
Omitting return types for function definitions will often work, but function parameters typically require annotations.
Definitions that are not functions, like <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.87142" data-verso-hover="213">unzipped</span></code> in the example, do not need type annotations if their bodies do not need type annotations, and the body of this definition is a function application.</p>
              <div class="paragraph">
                <p>
                  Omitting the return type for <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-NRT.unzip" data-verso-hover="216">unzip</span></code> is possible when using an explicit <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> expression:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-37295">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NRT.unzip" data-verso-hover="216">unzip</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87390" data-verso-hover="209">pairs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87383" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">×</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87385" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-37336" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87390" data-verso-hover="209">pairs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-37336" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87462" data-verso-hover="121">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87463" data-verso-hover="190">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87464" data-verso-hover="209">xys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-37397" data-verso-hover="212">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87467" data-verso-hover="213">unzipped</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-NRT.unzip" data-verso-hover="216">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87464" data-verso-hover="209">xys</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87462" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87467" data-verso-hover="213">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.fst" data-verso-hover="210">fst</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87463" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87467" data-verso-hover="213">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.snd" data-verso-hover="211">snd</span><span class="unknown token" data-binding="">)</span></code></div>
              <div class="paragraph">
                <p>
                  Generally speaking, it is a good idea to err on the side of too many, rather than too few, type annotations.
First off, explicit types communicate assumptions about the code to readers.
Even if Lean can determine the type on its own, it can still be easier to read code without having to repeatedly query Lean for type information.
Secondly, explicit types help localize errors.
The more explicit a program is about its types, the more informative the error messages can be.
This is especially important in a language like Lean that has a very expressive type system.
Thirdly, explicit types make it easier to write the program in the first place.
The type is a specification, and the compiler's feedback can be a helpful tool in writing a program that meets the specification.
Finally, Lean's type inference is a best-effort system.
Because Lean's type system is so expressive, there is no “best” or most general type to find for all expressions.
This means that even if you get a type, there's no guarantee that it's the <em>right</em> type for a given application.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="typed token" data-binding="" data-verso-hover="5">14</span></code> can be a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> or an <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">14 : Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-38158">#check</span></span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">14</span></code><div class="information">
                  <pre>14 : Nat</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">14 : Int</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-38256">#check</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="27">14</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span></code><div class="information">
                  <pre>14 : Int</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Missing type annotations can give confusing error messages.
Omitting all types from the definition of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-unzip" data-verso-hover="217">unzip</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-37894">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-unzip" data-verso-hover="217">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87727" data-verso-hover="218">pairs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-37915" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87727" data-verso-hover="218">pairs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-37915" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid match-expression, pattern contains metavariables
  []</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span></span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87901" data-verso-hover="219">x</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87902" data-verso-hover="220">y</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87903" data-verso-hover="218">xys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-37976" data-verso-hover="212">let</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87906" data-verso-hover="221">unzipped</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="const token" data-binding="const-unzip" data-verso-hover="217">unzip</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87903" data-verso-hover="218">xys</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87901" data-verso-hover="219">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87906" data-verso-hover="221">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.fst" data-verso-hover="210">fst</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87902" data-verso-hover="220">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87906" data-verso-hover="221">unzipped</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Prod.snd" data-verso-hover="211">snd</span><span class="unknown token" data-binding="">)</span></code><p>
                  leads to a message about the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> expression:</p>
                <div class="error">
                  <pre>invalid match-expression, pattern contains metavariables
  []</pre></div>
                <p>
                  This is because <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> needs to know the type of the value being inspected, but that type was not available.
A “metavariable” is an unknown part of a program, written <code>?m.XYZ</code> in error messages—they are described in the <a href="Getting-to-Know-Lean/Polymorphism/#polymorphism">section on Polymorphism</a>.
In this program, the type annotation on the argument is required.</p>
                </div>
              <div class="paragraph">
                <p>
                  Even some very simple programs require type annotations.
For instance, the identity function just returns whatever argument it is passed.
With argument and type annotations, it looks like this:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-37160">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NT.id" data-verso-hover="222">id</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87360" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87066" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87066" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87360" data-verso-hover="121">x</span></code><p>
                  Lean is capable of determining the return type on its own:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-37506">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NRT.id" data-verso-hover="222">id</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87690" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87383" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87690" data-verso-hover="121">x</span></code><p>
                  Omitting the argument type, however, causes an error:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-37731">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-id" data-verso-hover="223">id</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer binder type</code></span></span><span class="var token" data-binding="var-_uniq.87710" data-verso-hover="224">x</span></span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to infer definition type</code></span></span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87710" data-verso-hover="224">x</span></span></code><div class="error">
                  <pre>failed to infer binder type</pre></div>
                </div>
              <p>
                In general, messages that say something like “failed to infer” or that mention metavariables are often a sign that more type annotations are necessary.
Especially while still learning Lean, it is useful to provide most types explicitly.</p>
              </section>
            <section>
              <h2 id="simultaneous-matching">
                1.7.5. Simultaneous Matching<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=simultaneous-matching" title="Permalink">🔗</a></span></h2>
              <div class="paragraph">
                <p>
                  Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once.
Both the expressions to be inspected and the patterns that they match against are written with commas between them, similarly to the syntax used for definitions.
Here is a version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Match.drop" data-verso-hover="225">drop</span></code> that uses simultaneous matching:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-38386">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.drop" data-verso-hover="225">drop</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87988" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.87991" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.89241" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.89241" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-38435" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87988" data-verso-hover="5">n</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.87991" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-38435" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88009" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88009" data-verso-hover="137">ys</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88056" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88057" data-verso-hover="121">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88058" data-verso-hover="137">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.drop" data-verso-hover="225">drop</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88056" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88058" data-verso-hover="137">ys</span></code></div>
              <div class="paragraph">
                <p>
                  Simultaneous matching resembles matching on a pair, but there is an important difference.
Lean tracks the connection between the expression being matched and the patterns, and this information is used for purposes that include checking for termination and propagating static type information.
As a result, the version of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-sameLength" data-verso-hover="188">sameLength</span></code> that matches a pair is rejected by the termination checker, because the connection between <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.56895" data-verso-hover="137">xs</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.56978" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56979" data-verso-hover="137">xs'</span></code> is obscured by the intervening pair:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34079">def</span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">fail to show termination for
  sameLength
with errors
failed to infer structural recursion:
Not considering parameter α of sameLength:
  it is unchanged in the recursive calls
Not considering parameter β of sameLength:
  it is unchanged in the recursive calls
Cannot use parameter xs:
  failed to eliminate recursive application
    sameLength xs' ys'
Cannot use parameter ys:
  failed to eliminate recursive application
    sameLength xs' ys'


Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
              xs ys
1) 1763:28-46  ?  ?
Please use `termination_by` to specify a decreasing measure.</code></span></span><span class="const token" data-binding="const-sameLength" data-verso-hover="188">sameLength</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56895" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96816" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56898" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96818" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34136" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56895" data-verso-hover="137">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56898" data-verso-hover="189">ys</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34136" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.56978" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56979" data-verso-hover="137">xs'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56980" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56981" data-verso-hover="189">ys'</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-sameLength" data-verso-hover="188">sameLength</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56979" data-verso-hover="137">xs'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.56981" data-verso-hover="189">ys'</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code><div class="error">
                  <pre>fail to show termination for
  sameLength
with errors
failed to infer structural recursion:
Not considering parameter α of sameLength:
  it is unchanged in the recursive calls
Not considering parameter β of sameLength:
  it is unchanged in the recursive calls
Cannot use parameter xs:
  failed to eliminate recursive application
    sameLength xs' ys'
Cannot use parameter ys:
  failed to eliminate recursive application
    sameLength xs' ys'


Could not find a decreasing measure.
The basic measures relate at each recursive call as follows:
(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
              xs ys
1) 1763:28-46  ?  ?
Please use `termination_by` to specify a decreasing measure.</pre></div>
                <p>
                  Simultaneously matching both lists is accepted:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-34614">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Both.sameLength" data-verso-hover="188">sameLength</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.84412" data-verso-hover="137">xs</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96816" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.84415" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-List" data-verso-hover="111">List</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.96818" data-verso-hover="113">β</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34671" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84412" data-verso-hover="137">xs</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84415" data-verso-hover="189">ys</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-34671" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84475" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84476" data-verso-hover="137">xs'</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84477" data-verso-hover="190">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">::</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84478" data-verso-hover="189">ys'</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Both.sameLength" data-verso-hover="188">sameLength</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84476" data-verso-hover="137">xs'</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.84478" data-verso-hover="189">ys'</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.false" data-verso-hover="19">false</span></code></div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Natural-Number-Patterns">
                1.7.6. Natural Number Patterns</h2>
              <div class="paragraph">
                <p>
                  In the section on <a href="Getting-to-Know-Lean/Datatypes-and-Patterns/#datatypes-and-patterns">datatypes and patterns</a>, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-even" data-verso-hover="104">even</span></code> was defined like this:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-15648">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-even" data-verso-hover="104">even</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.13222" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15679" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13222" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-15679" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13239" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.not" data-verso-hover="105">not</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-even" data-verso-hover="104">even</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.13239" data-verso-hover="5">k</span><span class="unknown token" data-binding="">)</span></code><p>
                  Just as there is special syntax to make list patterns more readable than using <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.cons" data-verso-hover="132">List.cons</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.nil" data-verso-hover="133">List.nil</span></code> directly, natural numbers can be matched using literal numbers and <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span></code>.
For example, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Match.even" data-verso-hover="226">even</span></code> can also be defined like this:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-38576">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.even" data-verso-hover="226">even</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool" data-verso-hover="40">Bool</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.true" data-verso-hover="97">true</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88417" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Bool.not" data-verso-hover="105">not</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Match.even" data-verso-hover="226">even</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88417" data-verso-hover="5">n</span><span class="unknown token" data-binding="">)</span></code><p>
                  In this notation, the arguments to the <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span></code> pattern serve different roles.
Behind the scenes, the left argument (<code class="hl lean inline" data-lean-context="examples"><span class="var token" data-binding="var-_uniq.88417" data-verso-hover="5">n</span></code> above) becomes an argument to some number of <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code> patterns, and the right argument (<code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">1</span></code> above) determines how many <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code>s to wrap around the pattern.
The explicit patterns in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Match.Explicit.halve" data-verso-hover="227">halve</span></code>, which divides a <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> by two and drops the remainder:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-38710">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.Explicit.halve" data-verso-hover="227">halve</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.zero" data-verso-hover="26">Nat.zero</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88577" data-verso-hover="5">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.Explicit.halve" data-verso-hover="227">halve</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88577" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code><p>
                  can be replaced by numeric literals and <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-38881">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.halve" data-verso-hover="228">halve</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88922" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.halve" data-verso-hover="228">halve</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.88922" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code><p>
                  Behind the scenes, both definitions are completely equivalent.
Remember: <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Match.halve" data-verso-hover="228">halve</span><span class="var token" data-binding="var-_uniq.88922" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code> is equivalent to <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Match.halve" data-verso-hover="228">halve</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.89134" data-verso-hover="5">n</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>, not <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Match.halve" data-verso-hover="228">halve</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.89134" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span></code>.</p>
                </div>
              <div class="paragraph">
                <p>
                  When using this syntax, the second argument to <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span></code> should always be a literal <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>.
Even though addition is commutative, flipping the arguments in a pattern can result in errors like the following:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-39419">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Match.Oops.halve" data-verso-hover="229">halve</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">invalid patterns, `n` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching
  .(Nat.add 2 n)</code></span></span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="unknown token" data-binding="">halve</span><span class="inter-text"> </span><span class="unknown token" data-binding="">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span></span></code><div class="error">
                  <pre>invalid patterns, `n` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching
  .(Nat.add 2 n)</pre></div>
                <p>
                  This restriction enables Lean to transform all uses of the <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">+</span></code> notation in a pattern into uses of the underlying <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.succ" data-verso-hover="98">Nat.succ</span></code>, keeping the language simpler behind the scenes.</p>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Anonymous-Functions">
                1.7.7. Anonymous Functions</h2>
              <div class="paragraph">
                <p>
                  Functions in Lean need not be defined at the top level.
As expressions, functions are produced with the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">fun</span></code> syntax.
Function expressions begin with the keyword <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">fun</span></code>, followed by one or more parameters, which are separated from the return expression using <code>=&gt;</code>.
For instance, a function that adds one to a number can be written:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; x + 1 : Nat → Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-39763">#check</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-39770">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90781" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90781" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code><div class="information">
                  <pre>fun x =&gt; x + 1 : Nat → Nat</pre></div>
                <p>
                  Type annotations are written the same way as on <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code>, using parentheses and colons:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt; x + 1 : Int → Int</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-39882">#check</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-39889">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90897" data-verso-hover="27">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Int" data-verso-hover="28">Int</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90897" data-verso-hover="27">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="27">1</span></code><div class="information">
                  <pre>fun x =&gt; x + 1 : Int → Int</pre></div>
                <p>
                  Similarly, implicit parameters may be written with curly braces:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun {α} x =&gt; x : {α : Type} → α → α</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-40031">#check</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-40038">fun</span><span class="inter-text"> </span><span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.90966" data-verso-hover="113">α</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="unknown token" data-binding="">}</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.90968" data-verso-hover="121">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90966" data-verso-hover="113">α</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90968" data-verso-hover="121">x</span></code><div class="information">
                  <pre>fun {α} x =&gt; x : {α : Type} → α → α</pre></div>
                <p>
                  This style of anonymous function expression is often referred to as a <em>lambda expression</em>, because the typical notation used in mathematical descriptions of programming languages uses the Greek letter λ (lambda) where Lean has the keyword <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">fun</span></code>.
Even though Lean does permit <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">λ</span></code> to be used instead of <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">fun</span></code>, it is most common to write <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">fun</span></code>.</p>
                </div>
              <div class="paragraph">
                <p>
                  Anonymous functions also support the multiple-pattern style used in <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code>.
For instance, a function that returns the predecessor of a natural number if it exists can be written:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">fun x =&gt;
  match x with
  | 0 =&gt; none
  | n.succ =&gt; some n : Nat → Option Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-40223">#check</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-40230">fun</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91094" data-verso-hover="5">n</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91094" data-verso-hover="5">n</span></code><div class="information">
                  <pre>fun x =&gt;
  match x with
  | 0 =&gt; none
  | n.succ =&gt; some n : Nat → Option Nat</pre></div>
                <p>
                  Note that Lean's own description of the function has a named argument and a <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> expression.
Many of Lean's convenient syntactic shorthands are expanded to simpler syntax behind the scenes, and the abstraction sometimes leaks.</p>
                </div>
              <div class="paragraph">
                <p>
                  Definitions using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code> that take arguments may be rewritten as function expressions.
For instance, a function that doubles its argument can be written as follows:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-40333">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Double.double" data-verso-hover="230">double</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-40361">fun</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">0</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91252" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="unknown token" data-binding="">1</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Double.double" data-verso-hover="230">double</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.91252" data-verso-hover="5">k</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span></code><p>
                  When an anonymous function is very simple, like <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-39600">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90213" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.90213" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span></code>, the syntax for creating the function can be fairly verbose.
In that particular example, six non-whitespace characters are used to introduce the function, and its body consists of only three non-whitespace characters.
For these simple cases, Lean provides a shorthand.
In an expression surrounded by parentheses, a centered dot character <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">·</span></code> can stand for an parameter, and the expression inside the parentheses becomes the function's body.
That particular function can also be written <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">)</span></code>.</p>
                </div>
              <div class="paragraph">
                <p>
                  The centered dot always creates a function out of the <em>closest</em> surrounding set of parentheses.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">)</span></code> is a function that returns a pair of numbers, while <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="unknown token" data-binding="">)</span></code> is a pair of a function and a number.
If multiple dots are used, then they become parameters from left to right:</p>
                <div class="eval-steps">
                  <code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">·</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span></code><code class="hl lean block" data-lean-context="examples"><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="unknown token" data-binding="">)</span></code></div>
                <p>
                  Anonymous functions can be applied in precisely the same way as functions defined using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">def</span></code> or <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code>.
The command <code class="hl lean inline" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-40859" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-40866">fun</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92224" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92224" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92224" data-verso-hover="5">x</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code> results in:</p>
                <div class="information">
                  <pre>10</pre></div>
                <p>
                  while <code class="hl lean inline" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">10</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-40965" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">·</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span></code> results in:</p>
                <div class="information">
                  <pre>10</pre></div>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Namespaces">
                1.7.8. Namespaces</h2>
              <p>
                Each name in Lean occurs in a <em>namespace</em>, which is a collection of names.
Names are placed in namespaces using <code>.</code>, so <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map" data-verso-hover="231">List.map</span></code> is the name <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map" data-verso-hover="231">map</span></code> in the <code>List</code> namespace.
Names in different namespaces do not conflict with each other, even if they are otherwise identical.
This means that <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-List.map" data-verso-hover="231">List.map</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Array.map" data-verso-hover="232">Array.map</span></code> are different names.
Namespaces may be nested, so <code>Project.Frontend.User.loginTime</code> is the name <code>loginTime</code> in the nested namespace <code>Project.Frontend.User</code>.</p>
              <div class="paragraph">
                <p>
                  Names can be directly defined within a namespace.
For instance, the name <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.double" data-verso-hover="233">double</span></code> can be defined in the <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> namespace:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-41029">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat.double" data-verso-hover="233">Nat.double</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.92524" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92524" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92524" data-verso-hover="5">x</span></code><p>
                  Because <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code> is also the name of a type, dot notation is available to call <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat.double" data-verso-hover="233">Nat.double</span></code> on expressions with type <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">8</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-41298" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="5">4</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.double" data-verso-hover="233">double</span></code><div class="information">
                  <pre>8</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  In addition to defining names directly in a namespace, a sequence of declarations can be placed in a namespace using the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">namespace</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">end</span></code> commands.
For instance, this defines <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">triple</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-NewNamespace.quadruple" data-verso-hover="235">quadruple</span></code> in the namespace <code>NewNamespace</code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.namespace-41375" data-verso-hover="236">namespace</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NewNamespace</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-41398">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">triple</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.92644" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">3</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92644" data-verso-hover="5">x</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-41434">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-NewNamespace.quadruple" data-verso-hover="235">quadruple</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.92710" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92710" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">+</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">*</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92710" data-verso-hover="5">x</span><span class="inter-text">
</span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.end-41481" data-verso-hover="237">end</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NewNamespace</span></code><p>
                  To refer to them, prefix their names with <code>NewNamespace.</code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">NewNamespace.triple (x : Nat) : Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-41712">#check</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">NewNamespace.triple</span></code><div class="information">
                  <pre>NewNamespace.triple (x : Nat) : Nat</pre></div>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">NewNamespace.quadruple (x : Nat) : Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-41868">#check</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-NewNamespace.quadruple" data-verso-hover="235">NewNamespace.quadruple</span></code><div class="information">
                  <pre>NewNamespace.quadruple (x : Nat) : Nat</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Namespaces may be <em>opened</em>, which allows the names in them to be used without explicit qualification.
Writing <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">open</span></code> <code>MyNamespace </code><code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">in</span></code> before an expression causes the contents of <code>MyNamespace</code> to be available in the expression.
For example, <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-timesTwelve" data-verso-hover="238">timesTwelve</span></code> uses both <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-NewNamespace.quadruple" data-verso-hover="235">quadruple</span></code> and <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">triple</span></code> after opening <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">NewNamespace</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-41962">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-timesTwelve" data-verso-hover="238">timesTwelve</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.92870" data-verso-hover="5">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Nat" data-verso-hover="6">Nat</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-41993" data-verso-hover="239">open</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NewNamespace</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-41993" data-verso-hover="239">in</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="const token" data-binding="const-NewNamespace.quadruple" data-verso-hover="235">quadruple</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">triple</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.92870" data-verso-hover="5">x</span><span class="unknown token" data-binding="">)</span></code></div>
              <div class="paragraph">
                <p>
                  Namespaces can also be opened prior to a command.
This allows all parts of the command to refer to the contents of the namespace, rather than just a single expression.
To do this, place the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">open</span></code>﻿<code> ... </code><code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">in</span></code> prior to the command.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-42261" data-verso-hover="240">open</span><span class="inter-text"> </span><span class="unknown token" data-binding="">NewNamespace</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-42261">in</span><span class="inter-text">
</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">NewNamespace.quadruple (x : Nat) : Nat</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-42282">#check</span></span><span class="inter-text"> </span><span class="const token" data-binding="const-NewNamespace.quadruple" data-verso-hover="235">quadruple</span></code><div class="information">
                  <pre>NewNamespace.quadruple (x : Nat) : Nat</pre></div>
                <p>
                  Function signatures show the name's full namespace.
Namespaces may additionally be opened for <em>all</em> following commands for the rest of the file.
To do this, simply omit the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">in</span></code> from a top-level usage of <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">open</span></code>.</p>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--if-let">
                1.7.9. if let</h2>
              <div class="paragraph">
                <p>
                  When consuming values that have a sum type, it is often the case that only a single constructor is of interest.
For example, given this type that represents a subset of Markdown inline elements:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.inductive-42868" data-verso-hover="96">inductive</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="sort token" data-binding="" data-verso-hover="50">Type</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-null-42892">where</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.lineBreak" data-verso-hover="242">lineBreak</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.string" data-verso-hover="243">string</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.emph" data-verso-hover="244">emph</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.strong" data-verso-hover="245">strong</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">→</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span></code><p>
                  a function that recognizes string elements and extracts their contents can be written:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-43078">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-WithMatch.Inline.string?" data-verso-hover="246">Inline.string?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.93717" data-verso-hover="247">inline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-43136" data-verso-hover="100">match</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93717" data-verso-hover="247">inline</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-43136" data-verso-hover="100">with</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.string" data-verso-hover="243">Inline.string</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93731" data-verso-hover="39">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93731" data-verso-hover="39">s</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="unknown token" data-binding="">|</span><span class="inter-text"> </span><span class="unknown token" data-binding="">_</span><span class="inter-text"> </span><span class="unknown token" data-binding="">=&gt;</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span></code></div>
              <div class="paragraph">
                <p>
                  An alternative way of writing this function's body uses <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if</span></code> together with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code>:</p>
                <code class="hl lean block" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-43278">def</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.string?" data-verso-hover="246">Inline.string?</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.93824" data-verso-hover="247">inline</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline" data-verso-hover="241">Inline</span><span class="unknown token" data-binding="">)</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option" data-verso-hover="142">Option</span><span class="inter-text"> </span><span class="const token" data-binding="const-String" data-verso-hover="35">String</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-termIfLet-43336" data-verso-hover="248">if</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfLet-43336" data-verso-hover="248">let</span><span class="inter-text"> </span><span class="const token" data-binding="const-Inline.string" data-verso-hover="243">Inline.string</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93838" data-verso-hover="39">s</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93824" data-verso-hover="247">inline</span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termIfLet-43336" data-verso-hover="248">then</span><span class="inter-text">
</span><span class="inter-text">    </span><span class="const token" data-binding="const-Option.some" data-verso-hover="146">some</span><span class="inter-text"> </span><span class="var token" data-binding="var-_uniq.93838" data-verso-hover="39">s</span><span class="inter-text">
</span><span class="inter-text">  </span><span class="keyword token" data-binding="kw-occ-termIfLet-43336" data-verso-hover="248">else</span><span class="inter-text"> </span><span class="const token" data-binding="const-Option.none" data-verso-hover="145">none</span></code><p>
                  This is very much like the pattern-matching <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">let</span></code> syntax.
The difference is that it can be used with sum types, because a fallback is provided in the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">else</span></code> case.
In some contexts, using <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">if let</span></code> instead of <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">match</span></code> can make code easier to read.</p>
                </div>
              </section>
            <section>
              <h2 id="Functional-Programming-in-Lean--Getting-to-Know-Lean--Additional-Conveniences--Positional-Structure-Arguments">
                1.7.10. Positional Structure Arguments</h2>
              <p>
                The <a href="Getting-to-Know-Lean/Structures/#structures">section on structures</a> presents two ways of constructing structures:</p>
              <ol start="1">
                <li>
                  <p>
                    The constructor can be called directly, as in <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point.mk" data-verso-hover="78">Point.mk</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">1</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">2</span></code>.</p>
                  </li>
                <li>
                  <p>
                    Brace notation can be used, as in <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="">{</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.x" data-verso-hover="66">x</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point.y" data-verso-hover="66">y</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:=</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">2</span><span class="inter-text"> </span><span class="unknown token" data-binding="">}</span></code>.</p>
                  </li>
                </ol>
              <p>
                In some contexts, it can be convenient to pass arguments positionally, rather than by name, but without naming the constructor directly.
For instance, defining a variety of similar structure types can help keep domain concepts separate, but the natural way to read the code may treat each of them as being essentially a tuple.
In these contexts, the arguments can be enclosed in angle brackets <code>⟨</code> and <code>⟩</code>.
A <code class="hl lean inline" data-lean-context="examples"><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span></code> can be written <code class="hl lean inline" data-lean-context="examples"><span class="unknown token" data-binding="const-Point.mk" data-verso-hover="78">⟨</span><span class="typed token" data-binding="" data-verso-hover="60">1</span><span class="unknown token" data-binding="const-Point.mk" data-verso-hover="78">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">2</span><span class="unknown token" data-binding="const-Point.mk" data-verso-hover="78">⟩</span></code>.
Be careful!
Even though they look like the less-than sign <code>&lt;</code> and greater-than sign <code>&gt;</code>, these brackets are different.
They can be input using <code>\&lt;</code> and <code>\&gt;</code>, respectively.</p>
              <div class="paragraph">
                <p>
                  Just as with the brace notation for named constructor arguments, this positional syntax can only be used in a context where Lean can determine the structure's type, either from a type annotation or from other type information in the program.
For instance, <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-43998" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="unknown token" data-binding="">⟨</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span><span class="inter-text"> </span><span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">⟩</span></code> yields the following error:</p>
                <div class="error">
                  <pre>invalid constructor ⟨...⟩, expected type must be an inductive type 
  ?m.94053</pre></div>
                <p>
                  The metavariable in the error is because there is no type information available.
Adding an annotation, such as in <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-44139" data-verso-hover="7">#eval</span><span class="inter-text"> </span><span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="const-Point.mk" data-verso-hover="78">⟨</span><span class="typed token" data-binding="" data-verso-hover="60">1</span><span class="unknown token" data-binding="const-Point.mk" data-verso-hover="78">,</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="60">2</span><span class="unknown token" data-binding="const-Point.mk" data-verso-hover="78">⟩</span><span class="inter-text"> </span><span class="unknown token" data-binding="">:</span><span class="inter-text"> </span><span class="const token" data-binding="const-Point" data-verso-hover="63">Point</span><span class="unknown token" data-binding="">)</span></code>, solves the problem:</p>
                <div class="information">
                  <pre>{ x := 1.000000, y := 2.000000 }</pre></div>
                </div>
              </section>
            <section>
              <h2 id="string-interpolation">
                1.7.11. String Interpolation<span class="permalink-widget inline"><a href="find/?domain=Verso.Genre.Manual.section&name=string-interpolation" title="Permalink">🔗</a></span></h2>
              <div class="paragraph">
                <p>
                  In Lean, prefixing a string with <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="">s!</span></code> triggers <em>interpolation</em>, where expressions contained in curly braces inside the string are replaced with their values.
This is similar to <code>f</code>-strings in Python and <code>$</code>-prefixed strings in C#.
For instance,</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">"three fives is 15"</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-42413" data-verso-hover="7">#eval</span></span><span class="inter-text"> </span><span class="keyword token" data-binding="kw-occ-termS!_-42419">s!</span><span class="unknown token" data-binding="">"three fives is {</span><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">NewNamespace.triple</span><span class="inter-text"> </span><span class="typed token" data-binding="" data-verso-hover="5">5</span><span class="unknown token" data-binding="">}"</span></code><p>
                  yields the output</p>
                <div class="information">
                  <pre>"three fives is 15"</pre></div>
                </div>
              <div class="paragraph">
                <p>
                  Not all expressions can be interpolated into a string.
For instance, attempting to interpolate a function results in an error.</p>
                <code class="hl lean block" data-lean-context="examples"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">toString "three fives is " ++ sorry ++ toString "" : String</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-42767">#check</span></span><span class="inter-text"> </span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">failed to synthesize
  ToString (Nat → Nat)

Additional diagnostic information may be available using the `set_option diagnostics true` command.</code></span></span><span class="keyword token" data-binding="kw-occ-termS!_-42774">s!</span><span class="unknown token" data-binding="">"three fives is {</span><span class="const token" data-binding="const-NewNamespace.triple" data-verso-hover="234">NewNamespace.triple</span><span class="unknown token" data-binding="">}"</span></span></code><p>
                  yields the error</p>
                <div class="error">
                  <pre>failed to synthesize
  ToString (Nat → Nat)

Additional diagnostic information may be available using the `set_option diagnostics true` command.</pre></div>
                <p>
                  This is because there is no standard way to convert functions into strings.
The Lean compiler maintains a table that describes how to convert values of various types into strings, and the message <code>failed to synthesize instance</code> means that the Lean compiler didn't find an entry in this table for the given type.
This uses the same language feature as the <code class="hl lean inline" data-lean-context="examples"><span class="keyword token" data-binding="kw-occ-null-7526">deriving</span><span class="inter-text"> </span><span class="const token" data-binding="const-Repr" data-verso-hover="64">Repr</span></code> syntax that was described in the <a href="Getting-to-Know-Lean/Structures/#structures">section on structures</a>.</p>
                </div>
              </section>
            </section>
          <nav class="prev-next-buttons">
            <a class="local-button active" href="Getting-to-Know-Lean/Polymorphism/#polymorphism" rel="prev" title="1.6. Polymorphism"><span class="arrow">←</span><span class="where">1.6. Polymorphism</span></a><a class="local-button active" href="Getting-to-Know-Lean/Summary/#Functional-Programming-in-Lean--Getting-to-Know-Lean--Summary" rel="next" title="1.8. Summary"><span class="where">1.8. Summary</span><span class="arrow">→</span></a></nav>
          </div>
        </main></div>
    </body>
  </html>

